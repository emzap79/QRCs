%%%%%%%%%%%%%%
%  preamble  %
%%%%%%%%%%%%%%
% TeX Format

% version
\def\content{\uppercase{vim}}
\def\shortcontent{\content}
\def\versionnumber{1.7}  % Version of this reference card
\def\version{v\versionnumber\ \month\ \year}

% include stylefile
\input mydefs.sty
\mytitle

% shortcopyrightnotice
\shortintro
\shortintroVim

%%%%%%%%%%%%%%%%%%
%  card content  %
%%%%%%%%%%%%%%%%%%
\subsection{Helpsections}	{}
\cmdS{\tt :h <topic> }{will open the vimdocs to each $topic$s help-page.}
\cmdS{\tt :viu }{ show a summary of all commands.}

\section{Movements: Normal Mode}	{Press $ESC$ in order to reach from either visual- or insert-mode into normal mode.}
\subsection{Basic Movements}{\hright{\tt :h motion}}
\cmdS{h l k j }	{character left, right; line up, down }
\cmdS{b w }	{word\or token left, right }
\cmdS{ge e }	{end of word\or token left, right}
\cmdS{0 \_\ \$ }	{beginning, first, last character of line}
\cmdS{$n$G $n$gg }	{line $n$, default the last, first}
\cmdS{$n|$ }	{column $n$ of current line}
\cmdS{\% }	{match of next brace, bracket, comment, {\tt\#define}}
\cmdS{- + }	{line up, down on first non-blank character}
\cmdS{B W }	{space-separated word left, right}
\cmdS{gE E }	{end of space-separated word left, right}
\cmdS{g0 gm }	{beginning, middle of {\it screen\/} line}
\cmdS{g\^\ g\$ }	{first, last character of {\it screen\/} line}
\cmdS{f$char$ F$char$ }	{next, previous occurence of character $char$}
\cmdS{t$char$ T$char$ }	{before next, previous occurence of $char$}

\subsection{Jumps | {print jump list {\tt :jumps}}}	{\hright {\tt :h various-motions}}
\cmdS{\lapos\ \rapos }	{beginning of previous, next paragraph}
\cmdS{( ) }	{beginning of previous, next sentence}
\cmdS{[[\ ]]}	{go to previous, next function \or \bs section in \TeX}
\cmdS{[\lapos\ ]\rapos}	{beginning, end of current block}
\cmdS{[z ]z }	{move to start, end of current open fold}
\cmdS{$n$\ctrl O $n$\ctrl I }	{go to $n^{th}$ older, newer position in jump list}
\cmdS{$n$g; $n$g, }	{go to $n$ older, newer position in change list}
\cmdS{'. }	{jump back on last edited line}
\cmdS{'' }	{toggle back, forward to previous, next position}
\cmdS{`$0..9$ }	{go to last exit position}
\cmdS{``  `" }	{go to position before jump, at last edit}
\cmdS{`[ `] }	{go to start, end of previously operated text}
\cmdS{\ctrl ] \ctrl T }	{jump to the tag under cursor, return from tag (eg. inside of vimdocs)}

\subsection{Advanced Scrolling}	{}
\cmdS{$n$\ctrl Y $n$\ctrl E}	{scroll window $n$ lines up, downwards}
\cmdS{\ctrl D \ctrl U }	{scroll half a page up, down}
\cmdS{\ctrl F \ctrl B }	{scroll page up, down}
\cmdS{zt zz zb }	{current line to top, center, bottom of win.}
\cmdS{zh zl }	{scroll one character to the right, left}
\cmdS{zH zL }	{scroll half a screen to the right, left}
\cmdS{H M L}	{jump to $high$, $middle$, $low$ position in screen}

\section{Movements: Insert Mode}	{}
\subsection{Insertion, Replace $\to$ insert mode}	{}
\cmdS{c$m$ }	{change text of movement command $m$}
\cmdS{cc\or S }	{change current line}
\cmdS{C }	{change to the end of line}
\cmdS{i a }	{insert before, after cursor}
\cmdS{o O }	{open a new line below, above the current line}
\cmdS{I A }	{insert at beginning, end of line}
\cmdS{gi gI }	{insert text on last edited line, first column}
\cmdS{r$char$ gr$char$ }	{replace character under cursor, without affecting layout}
\cmdS{R gR }	{replace characters starting at the cursor, without affecting layout}
\cmdS{s$char$}	{substitute character $char$ under cursor $\to$ insert mode}

\section{Movements: Visual Mode}	{refer to {\tt :h object-select}}
\cmdS{v V \ctrl V }	{start\or stop highlighting characters, lines, block}
\cmdS{o }	{exchange cursor position with start of highlighting}
\cmdS{gv }	{start highlighting on previous visual area}
\cmdS{aw as ap }	{select a word, a sentence, a paragraph}
\cmdS{ab aB }	{select a block ( ), a block {\tt\lapos}	{\tt\rapos}}
\cmdS{g\ctrl G}	{Count words, character lines and bytes of selection}

\vfil\break

\section{Advanced Operations}	{For a better understanding, how to yank,
delete and move text you need a good understanding of how registers work in
vim.\\\\Find more information\ldots \\ here: http://stackoverflow.com/a/1498026\\ and more
in detail: http://stackoverflow.com/a/3997110.}
\subsection{Deletion}	{refer to {\tt :h copy-move}}
\cmdS{x X }	{delete character under, before cursor}
\cmdS{d$m$ }	{delete text of movement command $m$}
\cmdS{dd D }	{delete current line, to the end of line}
\cmdS{u U }	{undo last command, restore last changed line}
\cmdExmpl{:u1|u}	{To revert the current buffer to the state before the very
first change remembered by Vim in the undo list, use the command} % http://stackoverflow.com/a/8569812/1483760
\cmdS{.\thinspace\thinspace\ctrl R }	{repeat last $n$ changes, redo last undo}

\subsection{Copying}	{\hright {\tt :h copy-move}}
\cmdS{"$x$ }	{use register $x$ for next delete, yank, put}
\cmdS{y$m$ }	{yank the text of movement command $m$}
\cmdS{yy\or Y }	{yank current line into register}
\cmdS{p P }	{put register after, before cursor position}
\cmdS{gp gP }	{like {\tt p}, {\tt P} leaving cursor behind new inserted text}
\cmdS{\rbracket p \lbracket p }	{like {\tt p}, {\tt P} with indent adjusted}

\subsection{Registers \& Macros}{\hright {\tt :h http://stackoverflow.com/a/1498026}}
\cmdM{:reg\enter, :reg $x$ }	{show content of all registers, single register $x$}
\cmdS{:@$x$ }	{execute register $x$ as an {\it Ex\/} command}
\cmdM{:let @$x$ = "$ch$"}	{apply character(s) $ch$ to register $x$}
\cmdExmpl{let @+ = @a}	{move text from clipboard (@+) to register $a$}
\cmdS{q$x$ q$X$ q}	{record, append, stop recording typed characters as macro into register $x$}
\cmdS{@@ }	{repeat previous recorded macro}
\cmdS{q$x$q}	{empty register $x$}
\cmdExmpl{:g/$p$/d $x$ | let @+ = @x}	{delete lines with pattern $p$ into Register $x$ and copy to clipboard afterwards}
\cmdS{q:~@: }	{list all, repeat macro}

\subsection{Search \& Substitute}	{
substitutions work like {\tt:s/$p$/$q$/$flag$}, you may limit your search to
an area between $r$anges ({\tt Ex ranges)}.}

\subsubsection{Search, Substitute Flags }{}
\cmdOper{c}	{confirm each substitution}
\cmdOper{e}	{do not issue error messages and continue as if no error occurred}
\cmdOper{g}	{replace all occurrences in the line}
\cmdOper{i I}	{ignore, mind case for the pattern (overwrites 'ignorecase' and 'smartcase' options)}
\cmdOper{p~\#~l}	{print the line containing the last substitute, like {\tt :list} , prepend line number afterwards}
\cmdOper{\&}	{must be the first one: keep flags from the previous substitute}
\cmdOper{n}	{report the number of matches, do not actually substitute.  (the [c] flag is ignored.) }

\subsection{Forward \& Backward Searches}	{refer to {\tt :h search-commands}}
\cmdS{/$s$\enter~?$s$\enter }	{search forward, backward for $s$}
\cmdL{/$s$/$o$\enter~?$s$?$o$\enter }	{search fwd, bwd for $s$ with offset $o$}

\subsubsection{Offsets}	{}
The offset gives the cursor position relative to the found match:\\
\cmdOper{$n$, -$n$}{lines down-, upwards, in col 1}
\cmdOper{$e$+$n$, $e$-$n$}{characters to the right, left of the end of the match}
\cmdOper{$s$+$n$, $e$-$n$}{characters to the right, left of the start of the match}
\cmdOper{$b$+$n$, $e$-$n$}{identical to s+,-$n$ above (mnemonic: begin)}
\cmdOper{;$p$}{perform another search}

\subsection{Quick Search Commands}	{}
\cmdS{n\or /\enter }	{repeat forward last search}
\cmdS{N\or~?\enter }	{repeat backward last search}
\cmdS{\# * }	{search backward, forward for word under cursor}
\cmdS{g\# g* }	{same, but also find partial matches}
\cmdS{gd gD }	{local, global definition of symbol under cursor}

\subsection{Substitutions}	{refer to {\tt :h :sub}}
\cmdS{:$r$s/$p$/$q$/g }	{substitute all $p$ by $q$ in range $r$}
% \cnd{$x:$ {\tt g}---all occurrences, {\tt c}---confirm changes}
\cmdS{:$r$s $q$ }	{repeat substitution with new $r$ \& $q$}
\cmdL{:$r$g/$x$/$e$ :$r$v/$x$/$e$ }	{execute $e$ on range $r$ where $x$ mat\-ches, not matches}
\cmdExmpl{:'$a$,'$b$g/$x$/-1j}	{join any line containing the string $x$ with
previous line, if it lies between the $a$ and $b$ marks}
\cmdL{:$r$g/$x$/s/$p$/$q$/g }	{for every line in $r$ containing $x$, substitute $p$ with $q$}
\cmdS{:$r$\&\&~:$r$\&}	{repeat last search or substitution on range $r$ with, without flags}

\subsection{Ex Ranges}	{refer to {\tt :h cmdline-ranges}}
\cmdOper{, }	{cursor position interpreted from current line}
\cmdOper{;\ }	{the cursor position will be set to line of last search\or substitution}
\cmdOper{$n$ }	{an absolute line number $n$}
\cmdOper{.\thinspace\thinspace\thinspace\$ }	{the current, last line in file}
\cmdOper{\% * }	{entire file, visual area}
\cmdOper{'$t$ }	{position of mark $t$}
\cmdOper{/$p$/~?$p$? }	{the next, previous line where $p$ matches}
\cmdOper{-$n$ +$n$ }	{preceding, appending line $n$}

\subsection{Patterns (differences to Perl)}	{refer to {\tt :h pattern} and {\tt :h /zero-width} }
\cmdOper{\bs$<$ \bs$>$ }	{start, end of word}
\cmdOper{\bs i \bs k \bs I \bs K }	{an identifier, keyword; excl\. digits}
\cmdOper{\bs f \bs p \bs F \bs P }	{a file name, printable char.; excl\. digits}
\cmdOper{\bs e \bs t \bs r \bs b }	{\key{esc}, \key{tab}, \key{\enter}, \key{$\gets$}}
\cmdOper{\bs = * \bs + }	{match $0..1$, $0..\infty$, $1..\infty$ of preceding atoms}
\cmdOper{\bs$\{n,m\}$ }	{match $n$ to $m$ occurrences}
\cmdOper{\bs$\{-\}$ }	{non-greedy match}
\cmdOper{\bs$|$ }	{separate two branches ($\equiv$ {\it or\/})}
\cmdOper{\bs( \bs) }	{group patterns into an atom}
\cmdOper{\& \bs{}1 }	{the whole matched pattern, $1^{st}$ {\tt()} group}
\cmdOper{\bs \& }	{a {\it branch}: matches last concat, but only if all preceding concats also match at the same position}
% http://vim.wikia.com/wiki/Search_patterns
\cmdExmpl{/.*red\bs\&.*blue}	{the following pattern finds all lines that contain both "red" and "blue", in any order}
\cmdOper{\bs u \bs l }	{upper, lowercase character}
\cmdOper{\bs U \bs L }	{id., whole pattern}
\cmdOper{\bs c \bs C }	{ignore, match case on pattern}
\cmdOper{\bs @= \bs @! }	{\tt $char$(?=pattern) $char$(?!pattern)\rm}
\cmdExmpl{{\it pattern}\bs(foo\bs)\bs @!\$}	{matches pattern, only when line is not ending in 'foo'}
\cmdOper{\bs @$<$= \bs @$<$! }	{\tt (?=pattern)$char$ (?!pattern)$char$\rm}
% http://unix.stackexchange.com/a/91472
\cmdExmpl{/\/\bs(\#.*\bs)\bs@<={\it pattern}}	{everything before the
comment `\#' is excluded from pattern}
\cmdOper{\bs @$>$ }	{\tt (?$>$pattern)\rm }
% http://vim.wikia.com/wiki/Search_across_multiple_lines
\cmdOper{\bs\_\^{} \bs\_\$ }	{start-of-line, end-of-line, anywhere in pattern}
\cmdOper{\bs\_. }	{any single char, including end-of-line}
\cmdExmpl{foo\bs\_\bs s*bar}	{find any pattern $foo\enskip bar$, even when divided by linebreak}
\cmdOper{\bs zs \bs ze }	{set start, end of pattern}
\cmdOper{\bs \%\^{} \bs\%\$ }	{match start, end of file}
\cmdOper{\bs \%$n$l \bs \%$n$c \bs \%$n$v }	{matches specific line, column, virtual column $n$}
\cmdOper{\bs \%x }	{match hex character}
\cmdOper{\bs\%{}V }	{match inside visual area}
\cmdOper{\bs\tt'\rm m }	{match with position of mark m}
\cmdOper{\bs\%(\bs) }	{unnamed grouping}
\cmdOper{\bs\_$[$ $]$ }	{collection with end-of-line included}
\cmdOper{\bs\%$[$ $]$ }	{sequence of optionally matched atoms}
\cmdOper{\bs{}v }	{very magic: patterns almost like perl}

\vfil\break\hfil\vfil\break

\section{Even More Advanced\ldots}{}
\subsection{Special Text Operations}{}
\cmdS{cgn dgn }	{change, delete the next search pattern match (repeat change, deletion with \key{.})}
\cmdS{J gJ }	{join current line with next, without space}
\cmdS{\tild~g\tild{$m$}}	{switch case and advance cursor, on movement $m$ }
\cmdS{gu$m$ gU$m$ }	{switch case, lc, uc on movement $m$}
\cmdS{guu gUU}	{lower-/uppercase line}

\subsection{Marks and Tags}	{{\tt :tags} print tag list, {\tt :marks} print the active marks list}
\cmdS{m$c$ }	{mark current position with mark $c\in[a..Z]$}
\cmdS{`$c$ `$C$ }	{go to mark $c$ in current, $C$ in any file}

\subsection{Ex Commands (\enter)}	{refer to {\tt :help holy-grail} for list of all commands}
\subsubsection{Tags}	{}
\cmdS{:ts\grey{elect} $t$ }	{list matching tags and select one for jump}
\cmdS{:tj\grey{ump} $t$ }	{jump to tag or select one if multiple matches}
\cmdS{:ta\grey{g} \ctrl[ }	{jump to tag (under cursor)}

\subsubsection{Reading from \& writing to files}	{}
\cmdS{:e\grey{dit} $f$ }	{edit file $f$, reload current file if no $f$}
\cmdS{:ar\grey{gs} $f_1 \ldots f_n$}	{load $n$ files to buffer in background}
\cmdS{:$r$w\grey{rite} $f$ }	{write range $r$ to file $f$ (this file if no $f$)}
\cmdS{:$r$w\grey{rite}\kern2pt$>>f$ }	{append range $r$ to file $f$}
\cmdS{:q\grey{uit} :q\grey{uit}! }	{quit and confirm, discard changes}
\cmdL{:wq\or :x\or ZZ}	{write to current file and exit}
\cmdL{:$r$d\grey{elete}~:$r$d\grey{elete} $x$ }	{delete range $r$ lines, into register $x$}

\subsubsection{Filter Lines}{}
\cmdS{!$mc$\enter }	{filter lines of movement $m$ through command $c$}
\cmdS{$n$!!$c$\enter }	{filter $n$ lines through command $c$}
\cmdS{:$r$!$c$ }	{filter range $r$ lines through command $c$}

\subsubsection{Insert, Send Content}	{}
\cmdS{:r $f$ }	{insert content of file $f$ below cursor}
\cmdS{:r!\ $c$ }	{insert output of command $c$ below cursor}
\cmdL{:$r$co\grey{py}\or :$r$t\ $a$}	{copy range $r$ below line $a$}
\cmdExmpl{:g/foobar/t\$}	{copy all lines containing $foobar$ to EOF}
\cmdS{:$r$m\grey{ove}\ $a$}	{id. but move}
\cmdL{:$r$ha\grey{rdcopy} > file.ps }	{print range to ps file}
\cmdS{:$r$ha $r$w!lp }	{sending $r$ to printer (printout)}

\subsubsection{Compile}	{}
\cmdL{:cl\grey{ist} :cf\grey{ile} }	{list all errors, read errors from file}
\cmdL{:cn\grey{ext} :cp\grey{revious} }	{display the next, previous error}
\cmdS{:comp\grey{iler} $c$ }	{set, show compiler plugins}
\cmdS{:cope\grey{n} }	{navigate errors from make}
\cmdS{:mak\grey{e} }	{run {\tt makeprg}, jump to first error}

\subsection{Standard Mode Formatting, Filtering}	{leave out $m$ for visual mode commands}
\subsubsection{Indentation}{set indent-foldmethod by {\tt :set fdm=indent}}
\cmdS{$<m\enspace>m$ }	{shift left, right text of movement $m$}
\cmdS{$n\hskip -0.3em>$ $n\hskip -0.3em<$ $=$ }	{indent, unindent $n$ levels, reindent}
\cmdS{$n<\kern-3pt<\enspace n>\kern-3pt>$ }	{shift $n$ lines left, right}
%\cmdS{:,2s/\ze #/\=repeat(' ',32) }	{indent comments ' #' to column 32}

\subsubsection{Alignment}{}
\cmdS{gq$m$ gqgq }	{format movement $m$, current line}
\cmdS{:$r$ce $w$ }	{center lines in range $r$ to width $w$}
\cmdS{:$r$ri $w$ }	{rightalign lines in range $r$ to width $w$}
\cmdS{:$r$le $i$ }	{left align lines in range with indent $i$}

\subsubsection{Folds}	{}
\cmdS{zf$m$ }	{create fold of movement $m$}
\cmdS{:$r$fo\grey{ld} }	{create fold for range $r$}
\cmdS{zd zE }	{delete fold at cursor, all in window}
\cmdS{zo zc zO zC }	{open, close one fold; recursively}
\cmdS{zj zk }	{move down, up to start, end of next fold}
\cmdS{zm zM }	{fold more, close all folds}
\cmdS{zr zR }	{fold less, open all folds}
\cmdS{zn zN zi }	{fold non, fold normal, invert folding}
\cmdS{:set fdc=$n$ }	{show foldcolumn to level $n$}

\subsection{Multiple Files, Buffers, Tabs (\enter)}	{execute $cmd$ in each buffer in the buffer list {\tt:bufdo cmd}}
\subsubsection{Generic Buffer Commands}	{}
\cmdS{:bufdo $c$}	{execute command $c$ on all open buffers}
\cmdExmpl{:bufdo exe "\%normal @$c$"}	{execute normal command $c$ on each open buffer} % http://stackoverflow.com/a/3024430/1483760
\cmdS{:tab ball }	{show buffers as tablist}
\cmdS{:buffers }	{show list of buffers}
\cmdS{:on }	{make current window one on screen}
\cmdS{:new :vnew }	{create new empty window (vert.)}
\cmdS{:b$n$ }	{switch to buffer $n$}
\cmdL{:bn :bp :bf :bl }	{buffer movement next, prev, first, last}
\cmdS{:bd$n$ }	{delete buffer $n$ (also with filename)}
\cmdExmpl{:bd *.ext \ctrl A}	{Delete all Buffers with Extension `ext'}
\cmdS{:badd f.txt }	{load file into new buffer}
% \cmdS{}	{execute $cmd$ in each buffer in the buffer list.}
\cmdS{:sb$n$ }	{Split window and edit buffer $n$ from the bufflist}

\subsubsection{Tab Management}	{}
\cmdS{:tabs }	{list all tabs including their displayed windows}
\cmdS{:tabfi\grey{rst} }	{go to first tab}
\cmdS{:tabl\grey{ast} }	{go to last tab}
\cmdS{:tabnew }	{open a new empty tab page}
\cmdS{:tabc\grey{lose} }	{close current tab page}
\cmdS{:qa\grey{ll} :wqa\grey{ll} }	{quit, and save all tabs}
\cmdS{:tabo\grey{nly} }	{close all other tabs}
\cmdS{gt gT }	{go to next, previous Tab}
\cmdS{$n$gt }	{goto tab in position $n$ }

\subsection{Miscellaneous}	{}
\subsubsection{Spell Check}	{activate spellcheck: {\tt :set spell spelllang=en\_us}}
\cmdS{]s\ [s }	{next, previous misspelled word}
\cmdS{zg zG }	{add good word (to internal word list)}
\cmdS{zug zuG}	{undo the addition of a word to the dictionary}
\cmdS{zw zW }	{mark bad word (to internal word list)}
\cmdS{z= }	{suggest corrections}

\subsubsection{Invocation}	{}
\cmdL{vimdiff $f_1$ $f_2$ }	{diff $file_1$ + $file_2$ using synchronized split windows}
\cmdL{vim -o/-O $f_1$ $f_2 \ldots f_n$ }	{open $files$ in horiz, vert split mode}
\cmdS{vim +$n$ $file$ }	{open $file$ at $n$th line (eof if $n$ omitted)}
\cmdS{vim +/$s$ $file$ }	{open $file$ and search for $string$ }
\cmdS{vim -S $name$ }	{reload vim-session $name$}

\subsubsection{Special operations}	{Usefull (and not so usefull) operations which don't fit to any other subsection :-)}
\cmdS{K }	{run {\tt keywordprg} (manpage) on word under cursor}
\cmdS{\ctrl A \ctrl X}	{increment, decrement number under cursor}
\cmdS{\ctrl L }	{redraw screen}
\cmdS{ga }	{show A{\smallrm SCII} value of character under cursor}
\cmdS{gf }	{open filename under cursor}
\cmdS{g\ctrl G}	{count words, characters, bytes (in selection or buffer)}
\cmdL{\ctrl K$c_1c_2$\or$c_1$\kern-1pt\backspace$c_2$ }	{enter digraph $\{c_1,c_2\}$}
\cmdExmpl{:digraphs\or:h digraph-table}	{for a complete list of all digraphs enter}

\subsection{Common Digraphs}	{}
\cmdS{\ctrl K$n$S \ctrl K$n$s}	{Superscript, subscript Number $n$}
\cmdM{\ctrl K$char$* \ctrl K$Char$*}	{small, Capital greek letter $char$}
\cmdS{\ctrl K$nn$}	{Vulgar fraction one $n^{th}$ eg. one half, one quarter etc.}

\vfil\break\hfil\vfil\break
\section{CTRL-Keys}	{}
\subsection{CTRL in Normal Mode}	{}
\subsubsection{CTRL-W}{Buffer Shortcuts}
\cmdS{\ctrl \^{} }	{toggle between the current and the last window}
\cmdS{\ctrl Wf gf }	{open file under cursor in new, current window}
\cmdS{\ctrl Ww \ctrl W\ctrl W }	{move to window below, above (wrap)}
\cmdS{\ctrl Wj \ctrl Wk }	{move to window below, above}
\cmdS{\ctrl Wt \ctrl Wb }	{move to top, bottom window}
\cmdS{\ctrl Wc \ctrl Wo }	{close current, all other window(s)}
\cmdS{\ctrl Ws \ctrl Wv }	{split window in two (vert.)}
\cmdS{\ctrl Wx\or\ctrl W\ctrl R}	{swap open buffer windows }
\cmdS{\ctrl W$n$+ \ctrl W$n$- }	{increase, decrease window size by $n$ lines}
\cmdS{\ctrl W$n>$ \ctrl W$n<$ }	{increase, decrease window width}
\cmdS{\ctrl W$=$ }	{Make all windows equally high and wide}
\cmdS{\ctrl W$\_$ \ctrl W$|$ }	{maximize current window height, width}
\cmdS{\ctrl W$n\_$ \ctrl W$n|$ }	{set current window heigth, width to $n$ }

\subsection{CTRL in Command, Insert Mode}	{}
\subsubsection{CTRL-R}{}
\cmdS{\ctrl R\ctrl A}	{content under cursor to command mode}
\cmdS{\ctrl R = 5*5}	{insert 25 into text}
\cmdS{\ctrl R$x$ \ctrl R\ctrl R$x$ }	{insert content of register $x$, literally}

\subsubsection{CTRL-X}{Keyword completion}
\cmdS{\ctrl{}X\ctrl{}L}	{whole lines}
\cmdS{\ctrl{}X\ctrl{}N \ctrl{}X\ctrl{}I}	{keywords in current file, plus included files}
\cmdS{\ctrl{}X\ctrl{}K \ctrl{}X\ctrl{}N}	{keywords in dictionary, thesaurus}
\cmdS{\ctrl{}X\ctrl{}]}	{tags}
\cmdS{\ctrl{}X\ctrl{}F}	{file names}
\cmdS{\ctrl{}X\ctrl{}D}	{definitions or macros}
\cmdS{\ctrl{}X\ctrl{}V}	{vim command line}
\cmdS{\ctrl{}X\ctrl{}U}	{user defined completion}
\cmdS{\ctrl{}X\ctrl{}O}	{omni completion}

\subsubsection{CTRL-$<\ldots>$}{}
\cmdS{\ctrl V$char$ \ctrl V$n$ }	{insert char $char$ literally, decimal value $n$}
\cmdS{\ctrl A \ctrl @}	{insert previously inserted text, stop insert $\to$ command mode}
\cmdS{\ctrl N \ctrl P }	{text completion before, after cursor}
\cmdS{\ctrl W \ctrl U }	{delete word before cursor, to start of line}
\cmdS{\ctrl D \ctrl T }	{shift left, right one shift width}
\cmdS{\ctrl O$c$ }	{execute $c$ in temporary command mode}
\cmdS{\key{esc}\or\ctrl\rbracket}	{abandon edition $\to$ command mode}

% \subsection{Plugin Commands}	{}
% \cmdS{:BufOnly }	{Deletes all other Buffers}

%% Footer
\copyrightnotice

% Ending
\vfil
\supereject
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
