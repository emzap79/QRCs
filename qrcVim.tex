% TeX Format

% version
\def\content{VIM}
\def\versionnumber{1.5}  % Version of this reference card
\def\version{v\versionnumber\ \month\ \year}

% include definitions
\input mydefs.sty

% Card content
% Header
%\hrule\vskip 3pt

\title{\uppercase{\content\ quick reference card}}

\shortintro
\shortintroVim

\vskip 1.5ex

\section{Movements}	{{\tt :viusage } show a summary of all commands }
\subsection{Basic Movements}{refer to helpsection {\tt :h motion.txt}}
\cmdS{h l k j }	{character left, right; line up, down }
\cmdS{b w }	{word/token left, right }
\cmdS{ge e }	{end of word/token left, right}
\cmdS{\lapos\ \rapos }	{beginning of previous, next paragraph}
\cmdS{( ) }	{beginning of previous, next sentence}
\cmdS{[[\ ]]}	{go to previous, next function}
\cmdS{[\lapos\ ]\rapos}	{beginning, end of current block}
\cmdS{0 \_\ \$ }	{beginning, first, last character of line}
\cmdS{$n$G $n$gg }	{line $n$, default the last, first}
\cmdS{$n|$ }	{column $n$ of current line}
\cmdS{\% }	{match of next brace, bracket, comment, {\tt\#define}}
\cmdS{- + }	{line up, down on first non-blank character}
\cmdS{B W }	{space-separated word left, right}
\cmdS{gE E }	{end of space-separated word left, right}
\cmdS{g0 gm }	{beginning, middle of {\it screen\/} line}
\cmdS{g\^\ g\$ }	{first, last character of {\it screen\/} line}
\cmdS{f$c$ F$c$ }	{next, previous occurence of character $c$}
\cmdS{t$c$ T$c$ }	{before next, previous occurence of $c$}

\section{Insert, Command \& Visual Mode}	{}
\subsection{Insertion, Replace $\to$ insert mode}	{}
\cmdS{i a }	{insert before, after cursor}
\cmdS{I A }	{insert at beginning, end of line}
\cmdS{gi gI }	{insert text on last edited line / first column}
\cmdS{o O }	{open a new line below, above the current line}
\cmdS{r$c$ }	{replace character under cursor with $c$}
\cmdS{gr$c$ }	{like {\tt r}, but without affecting layout}
\cmdS{R }	{replace characters starting at the cursor}
\cmdS{gR }	{like {\tt R}, but without affecting layout}
\cmdS{s$c$}	{substitute char. $c$ under cursor}
\cmdS{c$m$ }	{change text of movement command $m$}
\cmdS{cc\or S }	{change current line}
\cmdS{C }	{change to the end of line}

\subsection{Insert, Command Mode}	{}
\cmdS{\ctrl V$c$ \ctrl V$n$ }	{insert char $c$ literally, decimal value $n$}
\cmdS{\ctrl A }	{insert previously inserted text}
\cmdS{\ctrl @ }	{same as {\tt\ctrl A} and stop insert $\to$ command mode}
\cmdS{\ctrl N \ctrl P }	{text completion before, after cursor}
\cmdS{\ctrl W }	{delete word before cursor}
\cmdS{\ctrl U }	{delete to start of current line}
\cmdS{\ctrl D \ctrl T }	{shift left, right one shift width}
\cmdS{\ctrl O$c$ }	{execute $c$ in temporary command mode}
\cmdS{\key{esc}\or\ctrl\rbracket}	{abandon edition $\to$ command mode}

\subsection{Insert, Command Mode Completion}	{}
\subsubsection{CTRL-R}{}
\cmdS{\ctrl R\ctrl A}	{content under cursor to command mode}
\cmdS{\ctrl R$x$ \ctrl R\ctrl R$x$ }	{insert content of register $x$, literally}
\subsubsection{CTRL-X}{}
\cmdS{\ctrl{}X\ctrl{}L}	{whole lines}
\cmdS{\ctrl{}X\ctrl{}N \ctrl{}X\ctrl{}I}	{keywords in current file, plus included files}
\cmdS{\ctrl{}X\ctrl{}K \ctrl{}X\ctrl{}N}	{keywords in dictionary, thesaurus}
\cmdS{\ctrl{}X\ctrl{}]}	{tags}
\cmdS{\ctrl{}X\ctrl{}F}	{file names}
\cmdS{\ctrl{}X\ctrl{}D}	{definitions or macros}
\cmdS{\ctrl{}X\ctrl{}V}	{vim command line}
\cmdS{\ctrl{}X\ctrl{}U}	{user defined completion}
\cmdS{\ctrl{}X\ctrl{}O}	{omni completion}

\subsection{Visual Mode}	{:h object-select}
\cmdS{v V \ctrl V }	{start/stop highlighting characters, lines, block}
\cmdS{o }	{exchange cursor position with start of highlighting}
\cmdS{gv }	{start highlighting on previous visual area}
\cmdS{aw as ap }	{select a word, a sentence, a paragraph}
\cmdS{ab aB }	{select a block ( ), a block {\tt\lapos}	{\tt\rapos}}
\cmdS{g\ctrl G}	{Count words, character lines and bytes of selection}

\section{Delete, Copy to Registers}	{}
\subsection{Deletion}	{}
\cmdS{x X }	{delete character under, before cursor}
\cmdS{d$m$ }	{delete text of movement command $m$}
\cmdS{dd D }	{delete current line, to the end of line}
\cmdS{dgn }	{delete the next search pattern match}
\cmdS{:$r$d~:$r$d$x$ }	{delete range $r$ lines, into register $x$}
\cmdS{u U }	{undo last command, restore last changed line}

\subsection{Copying}	{}
\cmdS{"$x$ }	{use register $x$ for next delete, yank, put}
\cmdS{y$m$ }	{yank the text of movement command $m$}
\cmdS{yy\or Y }	{yank current line into register}
\cmdS{p P }	{put register after, before cursor position}
\cmdS{\rbracket p \lbracket p }	{like {\tt p}, {\tt P} with indent adjusted}
\cmdS{gp gP }	{like {\tt p}, {\tt P} leaving cursor after new text}

\subsection{Registers}{}
\cmdS{.\thinspace\thinspace\ctrl R }	{repeat last changes, redo last undo}
\cmdS{:reg~:reg $x$ }	{show the content of all, specific register $x$}
\cmdS{$n$.\ }	{repeat last changes with count replaced by $n$ }
\cmdS{q$c$ q$C$ }	{record, append typed characters in register $c$}
\cmdS{q }	{stop recording}
\cmdS{q$x$q}	{empty register $x$}
\cmdExmpl{:g/$c$/d $x$ | let @+ = @x}	{delete lines with pattern $c$ into Register $x$ and copy to clipboard afterwards}
\cmdS{@$c$ }	{execute the content of register $c$}
\cmdS{@@ }	{repeat previous {\tt @} command}
\cmdS{:@$c$ }	{execute register $c$ as an {\it Ex\/} command}
\cmdS{q:~@: }	{list all, repeat previous {\it Ex\/} command(s)}

\section{Advanced Operations}{}

\subsection{Join lines / change cases}{}
\cmdS{J gJ }	{join current line with next, without space}
\cmdS{\tild~g\tild{$m$}}	{switch case and advance cursor, on movement $m$ }
\cmdS{gu$m$ gU$m$ }	{switch case, lc, uc on movement $m$}
\cmdS{guu gUU}	{lower-/uppercase line}

\subsection{Advanced Scrolling}	{}
\cmdS{$n$\ctrl Y $n$\ctrl E}	{Scroll window $n$ lines up-/downwards}
\cmdS{\ctrl D \ctrl U }	{scroll half a page up, down}
\cmdS{\ctrl F \ctrl B }	{scroll page up, down}
\cmdS{zt zz zb }	{current line to top, center, bottom of win.}
\cmdS{zh zl }	{scroll one character to the right, left}
\cmdS{zH zL }	{scroll half a screen to the right, left}

\section{Search \& Substitute}	{refer to {\tt :h search-commands} and {\tt :h :sub}, respectively}
\subsection{Forward \& Backward Searches}	{}
\cmdS{/$s$\enter~?$s$\enter }	{search forward, backward for $s$}
\cmdL{/$s$/$o$\enter~?$s$?$o$\enter }	{search fwd, bwd for $s$ with offset $o$}
\cmdS{n\or /\enter }	{repeat forward last search}
\cmdS{N\or~?\enter }	{repeat backward last search}
\cmdS{\# * }	{search backward, forward for word under cursor}
\cmdS{g\# g* }	{same, but also find partial matches}
\cmdS{gd gD }	{local, global definition of symbol under cursor}

\vskip 5ex
\subsection{Substitutions}	{substitutions work as {\tt:s/$p$/$q$/$flag$} --
for appending $flags$ like $g$, $c$, $l$ etc, see flaglist below!}
\cmdS{:$r$s/$p$/$q$/g }	{substitute all $p$ by $q$ in range $r$}
% \cnd{$x:$ {\tt g}---all occurrences, {\tt c}---confirm changes}
\cmdS{:$r$s $x$ }	{repeat substitution with new $r$ \& $x$}
\cmdL{:$r$g/$p$/$c$ :$r$v/$p$/$c$ }	{execute {\it Ex\/} $c$ on range $r$ where $p$ mat\-ches, not matches}
\cmdS{:$r$g/$p$/-1j }	{join all lines in $r$ containing pattern $p$ with prev\. line}
\cmdL{:$r$g/$o$/s/$q$/$y$/g }	{for every line in $r$ containing $o$, substitute $p$ with $q$}
\cmdS{:'$a$,'$b$g/$o$/j}	{join any line containing the string $o$ to its subsequent line, if it lies between the $a$ and $b$ marks}

\subsection{Patterns (differences to Perl)}	{refer to {\tt :h pattern} and {\tt :h zero-width} }
\cmdOper{\bs$<$ \bs$>$ }	{start, end of word}
\cmdOper{\bs i \bs k \bs I \bs K }	{an identifier, keyword; excl\. digits}
\cmdOper{\bs f \bs p \bs F \bs P }	{a file name, printable char.; excl\. digits}
\cmdOper{\bs e \bs t \bs r \bs b }	{\key{esc}, \key{tab}, \key{\enter}, \key{$\gets$}}
\cmdOper{\bs = * \bs + }	{match $0..1$, $0..\infty$, $1..\infty$ of preceding atoms}
\cmdOper{\bs$\{n,m\}$ }	{match $n$ to $m$ occurrences}
\cmdOper{\bs$\{-\}$ }	{non-greedy match}
\cmdOper{\bs$|$ }	{separate two branches ($\equiv$ {\it or\/})}
\cmdOper{\bs( \bs) }	{group patterns into an atom}
\cmdOper{\bs \& \bs{}1 }	{the whole matched pattern, $1^{st}$ {\tt()} group}
% http://vim.wikia.com/wiki/Search_patterns
\cmdExmpl{/.*red\bs\&.*blue}	{the following pattern finds all lines that contain both "red" and "blue", in any order}
\cmdOper{\bs u \bs l }	{upper, lowercase character}
\cmdOper{\bs c \bs C }	{ignore, match case on next pattern}
\cmdOper{\bs \%x }	{match hex character}
\cmdOper{\bs @= \bs @! }	{\tt $char$(?=pattern) $char$(?!pattern)\rm}
\cmdOper{\bs @$<$= \bs @$<$! }	{\tt (?=pattern)$char$ (?!pattern)$char$\rm}
% http://unix.stackexchange.com/a/91472
\cmdExmpl{\\:\%s/\bs(\#.*\bs)\bs@<=pattern/saturn/g}	{everything which comes before the
comment sign `\#' gets ignored (special atom \bs@<=, to assert a match `before')}
% \cOperdS{\bs @$<$= \bs @$<$! }	{\tt (?$<$=pattern) (?$<$!pattern)\rm}
\cmdOper{\bs @$>$ }	{\tt (?$>$pattern)\rm }
\cmdOper{\bs\_\^{} \bs\_\$ }	{start-of-line/end-of-line, anywhere in pattern}
\cmdOper{\bs\_. }	{any single char, including end-of-line}
\cmdOper{\bs zs \bs ze }	{set start/end of pattern}
\cmdOper{\bs \%\^{} \bs\%\$ }	{match start/end of file}
\cmdOper{\bs\%{}V }	{match inside visual area}
\cmdOper{\bs\tt'\rm m }	{match with position of mark m}
\cmdOper{\bs\%(\bs) }	{unnamed grouping}
\cmdOper{\bs\_$[$ $]$ }	{collection with end-of-line included}
\cmdOper{\bs\%$[$ $]$ }	{sequence of optionally matched atoms}
\cmdOper{\bs{}v }	{very magic: patterns almost like perl}

\subsection{Substitute Flags}	{refer to {\tt :h :s\_flags}}
\cmdOper{c}	{Confirm each substitution}
\cmdOper{e}	{ do not issue error messages and continue as if no error occurred}
\cmdOper{g}	{Replace all occurrences in the line}
\cmdOper{i I}	{Ignore, don't ignore case for the pattern (overwrite 'ignorecase' and 'smartcase' options)}
\cmdOper{p~\#}	{Print the line containing the last substitute, prepend line number afterwards}
\cmdOper{l}	{Like [p] but print the text like $:list$}
\cmdOper{\&}	{must be the first one: keep flags from the previous substitute}
\cmdExmpl{:\&r\  (same as \\:s//$c$\or:\tild)}	{Repeat last search\or substitution with same substitute string}
\cmdOper{n}	{Report the number of matches, do not actually substitute.  (The [c] flag is ignored.) }

\vskip -0.2cm
\section{Ex Commands (\enter)}	{refer to {\tt :help holy-grail} for list of all {\it Ex\/} commands}
\subsection{Reading from \& writing to files}	{}
\cmdS{:e $f$ }	{edit file $f$, reload current file if no $f$}
\cmdS{:$r$w $f$ }	{write range $r$ to file $f$ (this file if no $f$)}
\cmdS{:$rw>$\kern-3pt$>f$ }	{append range $r$ to file $f$}
\cmdS{:q :q! }	{quit and confirm, quit and discard changes}
\cmdL{:wq\or :x\or ZZ}	{write to current file and exit}

\subsection{Filter Lines}{}
\cmdS{!$mc$\enter }	{filter lines of movement $m$ through command $c$}
\cmdS{$n$!!$c$\enter }	{filter $n$ lines through command $c$}
\cmdS{:$r$!$c$ }	{filter range $r$ lines through command $c$}

\subsection{Insert, Move Content}	{}
\cmdS{:r $f$ }	{insert content of file $f$ below cursor}
\cmdS{:r!\ $c$ }	{insert output of command $c$ below cursor}
\cmdS{:$r$co\ $a$ :$r$m\ $a$ }	{copy, move range $r$ below line $a$}
\cmdL{:$r$hardcopy $r$w!lp }	{sending $r$ to printer (printout)}
\cmdL{:$r$hardcopy > file.ps }	{print range to ps file}

\subsection{Ex Ranges}	{both {\tt ,} and {\tt ;} seperate line numbers. They differ in interpretation though (see also {\tt :h cmdline-ranges}).}
\cmdOper{, }	{cursor position interpreted from current line (this line)}
\cmdOper{;\ }	{the cursor position will be set to that line before interpreting the next line specifier (that line)}
\cmdOper{$n$ }	{an absolute line number $n$}
\cmdOper{.\thinspace\thinspace\thinspace\$ }	{the current, last line in file}
\cmdOper{\% * }	{entire file, visual area}
\cmdOper{'$t$ }	{position of mark $t$}
\cmdOper{/$p$/~?$p$? }	{the next, previous line where $p$ matches}
\cmdOper{-$n$ +$n$ }	{preceding/appending line number}

\subsection{Compile}	{}
\cmdS{:compiler $c$ }	{set/show compiler plugins}
\cmdS{:make }	{run {\tt makeprg}, jump to first error}
\cmdS{:cope }	{navigate errors from make}
\cmdS{:cn :cp }	{display the next, previous error}
\cmdS{:cl :cf }	{list all errors, read errors from file}

\section{Standard Mode Formatting/ Filtering}	{leave out $m$ for visual mode commands}

\subsection{Indentation}{set indent-foldmethod by {\tt :set fdm=indent}}
\cmdS{$<m\enspace>m$ }	{shift left, right text of movement $m$}
\cmdS{$n\hskip -0.3em>$ $n\hskip -0.3em<$ $=$ }	{indent/unindent $n$ levels, reindent}
\cmdS{$n<\kern-3pt<\enspace n>\kern-3pt>$ }	{shift $n$ lines left, right}
%\cmdS{:,2s/\ze #/\=repeat(' ',32) }	{indent comments ' #' to column 32}
\cmdS{G=gg}	{auto (re)indent entire document}

\subsection{Alignment}{}
\cmdS{gq$m$ gqgq }	{format movement $m$/current paragraph}
\cmdS{:$r$ce $w$ }	{center lines in range $r$ to width $w$}
\cmdS{:$r$ri $w$ }	{rightalign lines in range $r$ to width $w$}
\cmdS{:$r$le $i$ }	{left align lines in range with indent $i$}

\subsection{Folds}	{}
\cmdS{zf$m$ }	{create fold of movement $m$}
\cmdS{:$r$fo }	{create fold for range $r$}
\cmdS{zd zE }	{delete fold at cursor, all in window}
\cmdS{zo zc zO zC }	{open, close one fold; recursively}
\cmdS{[z ]z }	{move to start, end of current open fold}
\cmdS{zj zk }	{move down, up to start, end of next fold}
\cmdS{zm zM }	{fold more, close all folds}
\cmdS{zr zR }	{fold less, open all folds}
\cmdS{zn zN zi }	{fold non, fold normal, invert folding}
\cmdL{:set foldcolumn=$n$ }	{show foldcolumn $n$}

\section{Tags, marks \& jumps}{{\tt :tags} print tag list, {\tt :marks} print the active marks list}
\subsection{Marks, Motions, and Tags}	{}
\cmdS{m$c$ }	{mark current position with mark $c\in[a..Z]$}
\cmdS{`$c$ `$C$ }	{go to mark $c$ in current, $C$ in any file}
\cmdS{`$0..9$ }	{go to last exit position}
\cmdS{``  `" }	{go to position before jump, at last edit}
\cmdS{`[ `] }	{go to start, end of previously operated text}
\cmdS{$n$\ctrl O }	{go to $n^{th}$ older position in jump list}
\cmdS{$n$\ctrl I }	{go to $n^{th}$ newer position in jump list}
\cmdS{\ctrl ] \ctrl T }	{jump to the tag under cursor, return from tag}
\cmdS{:ts $t$ }	{list matching tags and select one for jump}
\cmdS{:tj $t$ }	{jump to tag or select one if multiple matches}

\subsection{Jumps}	{print the jump list with {\tt :jumps}}
\cmdS{:ta \ctrl[ }	{jump to tag (under cursor)}
\cmdS{\ctrl O \ctrl I }	{jump to older/newer location btw\. buffers}
\cmdS{$n$g; $n$g, }	{go to $n$ older/newer position in change list}
\cmdS{'. }	{jump back on last edited line}
\cmdS{'' }	{toggle back/forward to previous/next position}

\section{Multiple Files, Buffers, Tabs (\enter)}	{}
\subsection{Generic Buffer Commands}	{}
\cmdS{:tab ball }	{show buffers as tablist}
\cmdS{:buffers }	{show list of buffers}
\cmdS{:on }	{make current window one on screen}
\cmdS{:new :vnew }	{create new empty window (vert.)}
\cmdS{:b$n$ }	{switch to buffer $n$}
\cmdL{:bn :bp :bf :bl }	{buffer movement next, prev, first, last}
\cmdS{:bd$n$ }	{delete buffer $n$ (also with filename)}
\cmdS{:badd f.txt }	{load file into new buffer}
\cmdS{:sb$n$ }	{Split window and edit buffer $n$ from the bufflist}

\subsection{Buffer Shortcuts}	{:h ctrl-w }
\cmdS{:bd *.ext \ctrl A}	{Deletes all Buffers with Extension `ext'}
\cmdS{\ctrl \^{} }	{toggle between the current and the last window}
\cmdS{\ctrl Wf gf }	{open file under cursor in new/current window}
\cmdS{\ctrl Ww \ctrl W\ctrl W }	{move to window below, above (wrap)}
\cmdS{\ctrl Wj \ctrl Wk }	{move to window below, above}
\cmdS{\ctrl Wt \ctrl Wb }	{move to top/bottom window}
\cmdS{\ctrl Wc \ctrl Wo }	{close current/all other window(s)}
\cmdS{\ctrl Ws \ctrl Wv }	{split window in two (vert.)}
\cmdS{\ctrl Wx\or \ctrl W\ctrl R}	{swap open buffer windows }
\cmdS{\ctrl W$n$+ \ctrl W$n$- }	{increase/decrease window size by $n$ lines}
\cmdS{\ctrl W$n>$ \ctrl W$n<$ }	{increase/decrease window width}
\cmdS{\ctrl W = }	{Make all windows equally high and wide}
\cmdS{\ctrl W $n\_$ }	{set window height to $n$ (default: very high) }
\cmdS{\ctrl W $n|$ }	{set current window width to $n$ }

\subsection{Tab Management}	{}
\cmdS{:tabs }	{list all tabs including their displayed windows}
\cmdS{:tabfirst }	{go to first tab}
\cmdS{:tablast }	{go to last tab}
\cmdS{:tabnew }	{open a new empty tab page}
\cmdS{:tabc }	{close current tab page}
\cmdS{:wqa :qa }	{(save and) quit all tabs}
\cmdS{:tabo }	{close all other tabs}
\cmdS{gt gT }	{go to next/previous Tab}
\cmdS{$n$gt }	{goto tab in position $n$ }

\section{Miscellaneous}	{}

\subsection{Spell Check}	{}
\cmdL{:set spell spelllang=de\_20 }	{activate spellcheck}
\cmdS{]s\ [s }	{next, previous misspelled word}
\cmdS{zg zG }	{add good word (to internal word list)}
\cmdS{zug zuG}	{undo the addition of a word to the dictionary}
\cmdS{zw zW }	{mark bad word (to internal word list)}
\cmdS{z= }	{suggest corrections}

\subsection{Vim Start-Options}	{}
\cmdL{vimdiff $f_1$ $f_2$ }	{diff $file_1$ + $file_2$ using synchronized split windows}
\cmdL{vim -o/-O $f_1$ $f_2$ }	{open $files$ in horiz/vert split mode}
\cmdS{vim +$n$ $file$ }	{open $file$ at $n$th line (eof if $n$ omitted)}
\cmdS{vim +/$s$ $file$ }	{open $file$ and search for $string$ }
\cmdS{vim -S $name$ }	{reload vim-session $name$}

\subsection{Special operations}	{Usefull (and not so usefull) operations which don't fit any other section :-)}
\cmdS{K }	{run {\tt keywordprg} (manpage) on word under cursor}
\cmdS{\ctrl A \ctrl X}	{increment/decrement number under cursor}
\cmdS{\ctrl L }	{redraw screen}
\cmdS{\ctrl R = 5*5}	{insert 25 into text}
\cmdS{ga }	{show A{\smallrm SCII} value of character under cursor}
\cmdS{gf }	{open filename under cursor}
\cmdL{\ctrl K$c_1c_2$\or$c_1$\kern-1pt\backspace$c_2$ }	{enter digraph $\{c_1,c_2\}$}
\cmdExmpl{:digraphs\or:h digraph-table}	{for a complete list of all digraphs enter}

\subsection{Helpsections}	{}
% http://stevereads.com/weblog/2007/03/26/vim-and-negative-lookaheadlookbehindlookaround/
\cmdL{:h /zero-width}	{matches with `zero-width' \key{@!} patterns}

% \section{Plugin Commands}	{}
% \cmdS{:BufOnly }	{Deletes all other Buffers}

%% Footer
\copyrightnotice


% Ending
\vfil
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
