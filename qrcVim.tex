% VIM Quick Reference Card
% Copyright (c) 2009 Jonas Petong.
% TeX Format

% version
\def\content{VIM}
\def\versionnumber{1.0}  % Version of this reference card
\def\year{2014}
\def\month{May}
\def\version{v\versionnumber\ \month\ \year}

% include definitions
\input mydefs.sty

% Card content
% Header
%\hrule\vskip 3pt

\title{\content QUICK REFERENCE CARD}

\shortintro

\vskip 0.5cm
\cmdS{:viusage }{Show a summary of all commands }

\section{Movements}{}
\cmdS{h l k j }{character left, right; line up, down }
\cmdS{b w }{word/token left, right }
\cmdS{ge e }{end of word/token left, right}
\cmdS{\lapos\ \rapos }{beginning of previous, next paragraph}
\cmdS{( ) }{beginning of previous, next sentence}
\cmdS{[[\ ]]}{go to previous, next function}
\cmdS{[\lapos\ ]\rapos}{beginning, end of current block}
\cmdS{0 \^\ \$ }{beginning, first, last character of line}
\cmdS{$n$G $n$gg }{line $n$, default the last, first}
\cmdS{$n|$ }{column $n$ of current line}
\cmdS{\% }{match of next brace, bracket, comment, {\tt\#define}}
\cmdS{- + }{line up, down on first non-blank character}
\cmdS{B W }{space-separated word left, right}
\cmdS{gE E }{end of space-separated word left, right}
\cmdS{g0 gm }{beginning, middle of {\it screen\/} line}
\cmdS{g\^\ g\$ }{first, last character of {\it screen\/} line}
\cmdS{f$c$ F$c$ }{next, previous occurence of character $c$}
\cmdS{t$c$ T$c$ }{before next, previous occurence of $c$}

\section{Jumps}{}
\cmdS{:jumps }{print the jump list}
\cmdS{:ta \ctrl[ }{jump to tag (under cursor)}
    \cmdS{\ctrl O \ctrl I }{jump to older/newer location btw\. buffers}
\cmdS{$n$g; $n$g, }{go to $n$ older/newer position in change list}
\cmdS{'. }{jump back on last edited line}
\cmdS{'' }{toggle back/forward to previous/next position}

\section{Insertion \& Replace $\to$ insert mode}{}
\cmdS{i a }{insert before, after cursor}
\cmdS{I A }{insert at beginning, end of line}
\cmdS{gi gI }{insert text on last edited line / first column}
\cmdS{o O }{open a new line below, above the current line}
\cmdS{r$c$ }{replace character under cursor with $c$}
\cmdS{gr$c$ }{like {\tt r}, but without affecting layout}
\cmdS{R }{replace characters starting at the cursor}
\cmdS{gR }{like {\tt R}, but without affecting layout}
\cmdS{s$c$}{substitute char. $c$ under cursor}
\cmdS{c$m$ }{change text of movement command $m$}
\cmdS{cc\or S }{change current line}
\cmdS{C }{change to the end of line}

\section{Deletion}{}
\cmdS{x X }{delete character under, before cursor}
\cmdS{d$m$ }{delete text of movement command $m$}
\cmdS{dd D }{delete current line, to the end of line}
\cmdS{dgn }{delete the next search pattern match}
\cmdS{J gJ }{join current line with next, without space}
\cmdS{:$r$d } {delete range $r$ lines}
\cmdS{:$r$d$x$ } {delete range $r$ lines into register $x$}
\cmdS{q$x$q}{empty register $x$}
\cmdL{:g/pattern/d $x$ | let @+ = @x} {delete lines with pattern $c$ into
Register $x$ and copy to clipboard afterwards.}

\section{Insert/ Command Mode}{}
\cmdS{\ctrl V$c$ \ctrl V$n$ }{insert char $c$ literally, decimal value $n$}
\cmdS{\ctrl V$n$ }{insert decimal value of character}
\cmdS{\ctrl A }{insert previously inserted text}
\cmdS{\ctrl @ }{same as {\tt\ctrl A} and stop insert $\to$ command mode}
\cmdS{\ctrl R$x$ \ctrl R\ctrl R$x$ }{insert content of register $x$, literally}
\cmdS{\ctrl R\ctrl W}{content under cursor to command mode}
\cmdS{\ctrl N \ctrl P }{text completion before, after cursor}
\cmdS{\ctrl W }{delete word before cursor}
\cmdS{\ctrl U }{delete to start of current line}
\cmdS{\ctrl D \ctrl T }{shift left, right one shift width}
\cmdS{\ctrl O$c$ }{execute $c$ in temporary command mode}
\cmdS{\ctrl X\ctrl E \ctrl X\ctrl Y }{scroll up, down}
\cmdS{\key{esc}\or \ctrl\rbracket\or \ctrl C}{abandon edition $\to$ command mode}

%\vskip 0.4cm
\section{Search \& Substitution}{}
\cmdS{/$s$\enter~?$s$\enter }{search forward, backward for $s$}
\cmdL{/$s$/$o$\enter~?$s$?$o$\enter }{search fwd, bwd for $s$ with offset $o$}
\cmdS{n\or /\enter }{repeat forward last search}
\cmdS{N\or~?\enter }{repeat backward last search}
\cmdS{\# * }{search backward, forward for word under cursor}
\cmdS{g\# g* }{same, but also find partial matches}
\cmdS{gd gD }{local, global definition of symbol under cursor}
\cmdS{:$r$s/$f$/$t$/$x$ } {substitute $f$ by $t$ in range $r$}
% \cnd{$x:$ {\tt g}---all occurrences, {\tt c}---confirm changes}
\cmdL{:$r$co\ $a$ :$r$m\ $a$ }{copy, move range $r$ below line $a$}
\cmdS{:$r$s $x$ } {repeat substitution with new $r$ \& $x$}
\cmdL{:$r$g/$p$/$c$ :$r$v/$p$/$c$ } {execute {\it Ex\/} $c$ on range $r$ where $p$ mat\-ches, not matches}
\cmdS{:$r$g/$p$/-1j }{join all lines in $r$ containing pattern $p$ with prev\. line}
\cmdL{:$r$g/$p$/s/$q$/$y$/g }{for every line in $r$ containing $p$, substitute $q$ with $y$}
\cmdS{:'$a$,'$b$g/$p$/j}{join any line containing the string $p$ to its subsequent line, if it lies between the $a$ and $b$ marks}

\vskip -0.2cm
\section{Misc Ex Commands (\enter)}{}
\cmdL{:help holy-grail }{show all Ex commands}
\cmdS{:e $f$ }{edit file $f$, reload current file if no $f$}
\cmdS{:$r$w $f$ }{write range $r$ to file $f$ (current file if no $f$)}
\cmdS{:$rw>$\kern-3pt$>f$ }{append range $r$ to file $f$}
\cmdS{:q :q! }{quit and confirm, quit and discard changes}
\cmdS{:wq\or :x\or ZZ }{write to current file and exit}
\cmdS{:r $f$ }{insert content of file $f$ below cursor}
\cmdS{:r!\ $c$ }{insert output of command $c$ below cursor}

\section{Miscellaneous}{}
\cmdL{:$r$hardcopy $r$w!lp }{sending $r$ to printer (printout)}
\cmdL{:$r$hardcopy > file.ps }{print range to ps file}
\cmdL{:mkview $[f]$ :loadview $[f]$ }{save/load configuration}
\cmdL{:mks $[f]$ :so $[f]$ }{save/load session}
\cmdS{:set ff=dos } {convert file to dos eol format}
\cmdL{:e ++ff=unix } {reopen file in unix eol format}
\cmdS{:sh :!$c$ } {start shell, execute command $c$ in shell}
\cmdS{K }{run {\tt keywordprg} (manpage) on word under cursor}
\cmdS{\ctrl L }{redraw screen}
\cmdS{\ctrl R = 5*5}{insert 25 into text}
\cmdS{ga }{show A{\smallrm SCII} value of character under cursor}
\cmdS{gf }{open file which filename is under cursor}
\cmdL{vim -S $name$ }{reload vim-session $name$}

\vskip -0.2cm
\section{Ex Ranges}{}
\cmdS{, ;\ }{separates line numbers, set to first line }
\cmdS{$n$ }{an absolute line number $n$}
\cmdS{.\thinspace\thinspace\thinspace\$ }{the current line, the last line in file}
\cmdS{\% * }{entire file, visual area}
\cmdS{'$t$ }{position of mark $t$}
\cmdS{/$p$/~?$p$? }{the next, previous line where $p$ matches}
\cmdS{-$n$ +$n$ }{preceding/appending line number}

%\vskip 0.4cm
\section{Standard Mode Formatting/ Filtering}{}
Leave out $m$ for visual mode commands \\
\cmdS{gq$m$ gqgq }{format movement $m$/current paragraph}
\cmdS{:$r$ce $w$ } {center lines in range $r$ to width $w$}
\cmdS{:$r$ri $w$ } {rightalign lines in range $r$ to width $w$}
\cmdS{:$r$le $i$ } {left align lines in range with indent $i$}
\cmdS{!$mc$\enter }{filter lines of movement $m$ through command $c$}
\cmdS{$n$!!$c$\enter }{filter $n$ lines through command $c$}
\cmdS{:$r$!$c$ } {filter range $r$ lines through command $c$}
\cmdS{\tild }{switch case and advance cursor}
\cmdL{g\tild{$m$} gu$m$ gU$m$ }{switch case, lc, uc on movement $m$}
\cmdS{guu gUU}{lower-/uppercase line}
\cmdS{$<m\enspace>m$ }{shift left, right text of movement $m$}
\cmdS{$n<\kern-3pt<\enspace n>\kern-3pt>$ }{shift $n$ lines left, right}
\cmdS{\ctrl A \ctrl X}{increment/decrement number under cursor}

%\vskip 0.8cm
\section{Visual Mode}{}
\cmdL{:h object-select}{Object selecting patterns}
\cmdS{v V \ctrl V }{start/stop highlighting characters, lines, block}
\cmdS{o }{exchange cursor position with start of highlighting}
\cmdS{gv }{start highlighting on previous visual area}
\cmdS{aw as ap }{select a word, a sentence, a paragraph}
\cmdS{ab aB }{select a block ( ), a block {\tt\lapos} {\tt\rapos}}
\cmdS{g\ctrl G}{Count words, character lines and bytes of selection}

\section{Undoing, Repeating \& Registers}{}
\cmdS{u U }{undo last command, restore last changed line}
\cmdS{.\thinspace\thinspace\ctrl R }{repeat last changes, redo last undo}
\cmdS{$n$.\ }{repeat last changes with count replaced by $n$ }
\cmdS{q$c$ q$C$ }{record, append typed characters in register $c$}
\cmdS{q }{stop recording}
\cmdS{@$c$ }{execute the content of register $c$}
\cmdS{@@ }{repeat previous {\tt @} command}
\cmdS{:@$c$ } {execute register $c$ as an {\it Ex\/} command}


\section{Copying}{}
\cmdS{"$x$ }{use register $x$ for next delete, yank, put}
\cmdS{:reg } {show the content of all registers}
\cmdS{:reg $x$ } {show the content of registers $x$}
\cmdS{y$m$ }{yank the text of movement command $m$}
\cmdS{yy\or Y }{yank current line into register}
\cmdS{p P }{put register after, before cursor position}
\cmdS{\rbracket p \lbracket p }{like {\tt p}, {\tt P} with indent adjusted}
\cmdS{gp gP }{like {\tt p}, {\tt P} leaving cursor after new text}



\section{Patterns (differences to Perl)}{}
\cmdL{:help pattern } {show complete help on patterns}
\cmdS{\bs$<$ \bs$>$ }{start, end of word}
\cmdS{\bs i \bs k \bs I \bs K }{an identifier, keyword; excl\. digits}
\cmdS{\bs f \bs p \bs F \bs P }{a file name, printable char.; excl\. digits}
\cmdS{\bs e \bs t \bs r \bs b }{\key{esc}, \key{tab}, \key{\enter}, \key{$\gets$}}
\cmdS{\bs = * \bs + }{match $0..1$, $0..\infty$, $1..\infty$ of preceding atoms}
\cmdS{\bs$\{n,m\}$ }{match $n$ to $m$ occurrences}
\cmdS{\bs$\{-\}$ }{non-greedy match}
\cmdS{\bs$|$ }{separate two branches ($\equiv$ {\it or\/})}
\cmdS{\bs( \bs) }{group patterns into an atom}
\cmdS{\bs \& \bs{}1 }{the whole matched pattern, $1^{st}$ {\tt()} group}
\cmdS{\bs u \bs l }{upper, lowercase character}
\cmdS{\bs c \bs C }{ignore, match case on next pattern}
\cmdS{\bs \%x }{match hex character}
\cmdS{\bs @= \bs @! }{\tt $char$(?=pattern) $char$(?!pattern)\rm}
\cmdS{\bs @$<$= \bs @$<$! }{\tt (?=pattern)$char$ (?!pattern)$char$\rm}
% \cmdS{\bs @$<$= \bs @$<$! }{\tt (?$<$=pattern) (?$<$!pattern)\rm}
\cmdS{\bs @$>$ }{\tt (?$>$pattern)\rm }
\cmdS{\bs\_\^{} \bs\_\$ }{start-of-line/end-of-line, anywhere in pattern}
\cmdS{\bs\_. }{any single char, including end-of-line}
\cmdS{\bs zs \bs ze }{set start/end of pattern}
\cmdS{\bs \%\^{} \bs\%\$ }{match start/end of file}
\cmdS{\bs\%{}V }{match inside visual area}
\cmdS{\bs\tt'\rm m }{match with position of mark m}
\cmdS{\bs\%(\bs) }{unnamed grouping}
\cmdS{\bs\_$[$ $]$ }{collection with end-of-line included}
\cmdS{\bs\%$[$ $]$ }{sequence of optionally matched atoms}
\cmdS{\bs{}v }{very magic: patterns almost like perl}


\vskip -0.2cm
\section{Spell Checking}{}
\cmdL{:set spell spelllang=de\_20 } {activate spellcheck}
\cmdS{]s\ [s }{next, previous misspelled word}
\cmdS{zg zG }{add good word (to internal word list)}
\cmdS{zug zuG}{undo the addition of a word to the dictionary}
\cmdS{zw zW }{mark bad word (to internal word list)}
\cmdS{z= }{suggest corrections}

\section{Marks, Motions, and Tags}{}
\cmdS{m$c$ }{mark current position with mark $c\in[a..Z]$}
\cmdS{:marks } {print the active marks list}
\cmdS{`$c$ `$C$ }{go to mark $c$ in current, $C$ in any file}
\cmdS{`$0..9$ }{go to last exit position}
\cmdS{``  `" }{go to position before jump, at last edit}
\cmdS{`[ `] }{go to start, end of previously operated text}
\cmdS{$n$\ctrl O }{go to $n^{th}$ older position in jump list}
\cmdS{$n$\ctrl I }{go to $n^{th}$ newer position in jump list}
\cmdS{\ctrl ] \ctrl T }{jump to the tag under cursor, return from tag}
\cmdS{:ts $t$ } {list matching tags and select one for jump}
\cmdS{:tj $t$ } {jump to tag or select one if multiple matches}
\cmdS{:tags } {print tag list}

\section{Multiple Files / Buffers (\enter)}{}
\cmdS{:tab ball }{show buffer tablist}
\cmdS{:buffers }{show list of buffers}
\cmdS{:on } {make current window one on screen}
\cmdS{:new :vnew } {create new empty window (vert.)}
\cmdS{:b$n$ }{switch to buffer $n$}
\cmdL{:bnext :bprev :bfirst :blast }{buffer movement}
\cmdS{:bd$n$ }{delete buffer $n$ (also with filename)}
\cmdS{:badd f.txt }{load file into new buffer}
\cmdS{:sb$n$ }{Split window and edit buffer $n$ from the bufflist}

\section{Buffer Shortcuts}{}
\cmdS{:h ctrl-w }{complete list of all buffer commands}
\cmdS{:bd *.ext \ctrl A}{Deletes all Buffers with Extension `ext'}
\cmdS{\ctrl \^{} }{toggle between the current and the last window}
\cmdS{\ctrl Wf gf }{open file under cursor in new/current window}
\cmdS{\ctrl Ww \ctrl W\ctrl W }{move to window below, above (wrap)}
\cmdS{\ctrl Wj \ctrl Wk }{move to window below, above}
\cmdS{\ctrl Wt \ctrl Wb }{move to top/bottom window}
\cmdS{\ctrl Wc \ctrl Wo }{close current/all other window(s)}
\cmdS{\ctrl Ws \ctrl Wv } {split window in two (vert.)}
\cmdS{\ctrl Wx } {swap open buffer windows }
\cmdS{\ctrl W$n$+ \ctrl W$n$- }{increase/decrease window size by $n$ lines}
\cmdS{\ctrl W$n>$ \ctrl W$n<$ }{increase/decrease window width}
\cmdS{\ctrl W = } {Make all windows equally high and wide}
\cmdS{\ctrl W $n\_$ }{set window height to $n$ (default: very high) }
\cmdS{\ctrl W $n|$ }{set current window width to $n$ }

\section{Plugin Commands}{}
\cmdS{:BufOnly }{Deletes all other Buffers}

\section{Tab Management}{}
\cmdS{:tabs }{list all tabs including their displayed windows}
\cmdS{:tabfirst }{go to first tab}
\cmdS{:tablast }{go to last tab}
\cmdS{:tabnew }{open a new empty tab page}
\cmdS{:tabc }{close current tab page}
\cmdS{:wqa :qa }{(save and) quit all tabs}
\cmdS{:tabo }{close all other tabs}
\cmdS{gt gT }{go to next/previous Tab}
\cmdS{$n$gt }{goto tab in position $n$ }

\section{Advanced Scrolling}{}
\cmdS{$n$\ctrl Y $n$\ctrl E}{Scroll window $n$ lines up-/downwards}
\cmdS{\ctrl D \ctrl U }{scroll half a page up, down}
\cmdS{\ctrl F \ctrl B }{scroll page up, down}
\cmdS{zt zz zb }{current line to top, center, bottom of win.}
\cmdS{zh zl }{scroll one character to the right, left}
\cmdS{zH zL }{scroll half a screen to the right, left}


\vskip -0.2cm
\section{Completion}{}
\cmdS{\ctrl{}X\ctrl{}L}{whole lines}
\cmdS{\ctrl{}X\ctrl{}N \ctrl{}X\ctrl{}I}{keywords in current file, plus included files}
\cmdS{\ctrl{}X\ctrl{}K \ctrl{}X\ctrl{}N}{keywords in dictionary, thesaurus}
\cmdS{\ctrl{}X\ctrl{}]}{tags}
\cmdS{\ctrl{}X\ctrl{}F}{file names}
\cmdS{\ctrl{}X\ctrl{}D}{definitions or macros}
\cmdS{\ctrl{}X\ctrl{}V}{vim command line}
\cmdS{\ctrl{}X\ctrl{}U}{user defined completion}
\cmdS{\ctrl{}X\ctrl{}O}{omni completion}

\section{Folding}{}
\cmdS{zf$m$ }{create fold of movement $m$}
\cmdS{:$r$fo }{create fold for range $r$}
\cmdS{zd zE }{delete fold at cursor, all in window}
\cmdS{zo zc zO zC }{open, close one fold; recursively}
\cmdS{[z ]z }{move to start, end of current open fold}
\cmdS{zj zk }{move down, up to start, end of next fold}
\cmdS{zm zM }{fold more, close all folds}
\cmdS{zr zR }{fold less, open all folds}
\cmdS{zn zN zi }{fold non, fold normal, invert folding}
\cmdL{:set foldcolumn=$n$ } {show foldcolumn $n$}

\section{Compiling}{}
\cmdS{:compiler $c$ }{set/show compiler plugins}
\cmdS{:make } {run {\tt makeprg}, jump to first error}
\cmdS{:cope } {navigate errors from make}
\cmdS{:cn :cp } {display the next, previous error}
\cmdS{:cl :cf } {list all errors, read errors from file}

\section{Indentation}{}
\cmdL{:set fdm=indent } {indent-foldmethod}
%\cmdS{:,2s/\ze #/\=repeat(' ',32) }{indent comments ' #' to column 32}
\cmdS{$n\hskip -0.3em>$ $n\hskip -0.3em<$ $=$ }{indent/unindent $n$ levels, reindent}
\cmdS{$n\hskip -0.3em>>$ $n\hskip -0.3em<<$ }{indent/dedent $n$ lines}
\cmdS{G=gg}{auto (re)indent entire document}

\section{Vim Start-Options}{}
\cmdL{vimdiff $f_1$ $f_2$ }{diff $file_1$ + $file_2$ using synchronized split windows}
\cmdL{vim -o/-O $f_1$ $f_2$ }{open $files$ in horiz/vert split mode}
\cmdS{vim +$n$ $file$ }{open $file$ at $n$th line (eof if $n$ omitted)}
\cmdS{vim +/$s$ $file$ }{open $file$ and search for $string$ }

\section{Most Common Digraphs}{}
\cmdS{:dig }{complete list of all digraphs}
\cmdL{\ctrl K$c_1c_2$\or $c_1$\kern-1pt\backspace$c_2$ }{enter digraph $\{c_1,c_2\}$}
\cmdS{Co }{Copyright }
\cmdS{Rg }{Registered Trademark }
\cmdS{!I }{!`: Inverteted Excl. Mark }
\cmdS{?I }{?`: Inverteted Quest. Mark }
\cmdS{Eu }{Euro Currency }
\cmdS{Li }{Britain Pound Currency }
\cmdS{00 }{$\infty$ }
\cmdS{*p *P}{$\pi$ $\Pi$ }
\cmdS{14 12 34 }{1/4, 1/2, 3/4 etc.}

% % Footer
% \vfill \hrule\smallskip
% {\smallrm More examples for how to use Exec-Commands see:\\
% {\smalltt http://stackoverflow.com/a/1220118}}\\\\
% {\smallrm This card may be freely distributed under
% the terms of the GNU general public licence ---
% Copyright \copyright\ {\oldstyle 2014} by Jonas Petong.
% {\smalltt https://github.com/emzap79/QRCs}. Based on original by
% Laurent Gr\'egoire  ({\smalltt http://tnerual.eriogerg.free.fr/})
% }

% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
