%%%%%%%%%%%%%%
%  preamble  %
%%%%%%%%%%%%%%
% TeX Format

% version
\def\content{\uppercase{r}}
\def\shortcontent{\content}
\def\versionnumber{1.3}  % Version of this reference card
\def\version{v\versionnumber\ \month\ \year}

% include stylefile
\input mydefs.sty
\mytitle

% shortcopyrightnotice
\shortintro
\shortintroR

% Granted to the public domain. See www.Rpad.org for the source and latest
% version. Includes material from {\it R for Beginners} by Emmanuel Paradis
% (with permission). Some additions by James McCreight.

%%%%%%%%%%%%%%%%%%
%  card content  %
%%%%%%%%%%%%%%%%%%
\section{Help}{Most R functions have online documentation.}
\cmdS{help(topic)}	{documentation on {\tt topic}}
\cmdS{?topic}	{id.}
\cmdL{help.search("topic")}	{search the help system}
\cmdM{apropos("topic")}	{the names of all objects in the search list
    matching the regular ex\-pres\-sion "to\-pic"}
\cmdS{help.start()}	{start the HTML version of help}

\section{Input and output}{Most of the I/O functions have a {\tt file}
argument. This can often be a character string naming a file or a connection.
{\tt file=""} means the standard input or output. Connections can include
files, pipes, zipped files, and R variables. }

\subsection{Basic Operations}{}
\cmdS{<-}	{assign to an object, equivalent to =(?)}
\cmdS{<<-}	{lexical assignment (*NOT* global assignment)}
\cmdS{getwd()}	{get the working directory}
\cmdS{setwd()}	{set the working directory}
\cmdS{system()}	{call the operating system (shell)}
\cmdS{Sys.Date()}	{Retreive current date, without time}
\cmdM{system.time()}	{time an evaluation}
\cmdS{Sys.sleep()}	{pause}
\cmdS{str(a)}	{display the internal [{\tt str}]ucture of an R object a}
\cmdS{summary(a)}	{gives a ``summary'' of {\tt a}, usually a statistical summary but it is {\it generic} meaning it has different operations for different classes of {\tt a}}
\cmdS{ls()}	{show objects in the search path; specify {\tt pat="pat"} to search on a pattern}
\cmdS{ls.str()}	{str() for each variable in the search path}
\cmdS{dir()}	{show files in the current directory}
\cmdS{methods(a)}	{shows S3 methods of {\tt a}}
\cmdL{methods(class=class(a))}	{lists all the methods to handle objects of class a}

\subsection{Fundamentals}{}
\cmdS{load()}	{load the datasets written with {\tt save}}
\cmdS{data(x)}	{loads specified data set}
\cmdS{library(x)}	{load add-on packages}
\cmdM{save(file,...)}	{saves the specified objects (...) in the XDR
    platform-independent binary format}
\cmdM{save.image(file)}	{saves all objects}
\cmdL{cat(..., file="", sep=" ")}	{prints the arguments after
    coercing to character; {\tt sep} is the character separator between arguments}
\cmdS{print(a, \ldots)}	{prints its arguments; generic, meaning it can
    have different methods for different objects}
\cmdM{format(x,...)}	{format an R object for pretty printing}
\cmdS{sink(file)}	{output to {\tt file}, until {\tt sink()}}

\subsection{Read from File}{}
\cmdM{read.table(file)}	{reads a file in table format and creates a data frame
from it; the default separator {\tt sep=""} is any whitespace}
\cmdL{read.csv("filename",header=T)}	{id. but with defaults set for reading
comma-delimited files}
\cmdL{read.csv2("filename",header=T)}	{id. but with defaults set for
reading semicolon-delimited files and {\tt dec=","}}
\cmdL{read.delim("filename",header=T)}	{id. but with defaults set for reading
tab-delimited files}
\cmdL{{\smalltt read.fwf(file,widths,header=F,sep="\bs t",as.is=F)}}	{ read
a table of [{\tt f}]ixed [{\tt w}]idth [{\tt f}]or\-mat\-ted data into a
\emergencystretch=3em 'data.frame'; {\tt widths} is an integer vector, giving
the widths of the fixed-width fields}

\subsubsection{Read Options}{}
\cmdOpt{as.is=TRUE} {\\ to prevent character vectors from being converted to factors}
\cmdOpt{blank.lines.skip=TRUE} {\\ blank lines in the input are ignored.}
\cmdOpt{fill=TRUE} {\\ in case the rows have unequal length, blank fields are implicitly added}
\cmdOpt{header=TRUE} {\\ to read the first line as a header of column names}
\cmdOpt{comment.char=""} {\\ to prevent "\#" from being interpreted as a comment}
\cmdOpt{skip=n} {to skip $n$ lines before reading data}

% the help for options on row naming, NA treatment, and others}

\subsection{Write to file}{}
\cmdL{{\smalltt write.table(x,file="",row.names=T,col.names=T, sep=" ")}}
{prints {\tt x} after converting to a data frame; if {\tt quote} is {\tt TRUE},
character or factor columns are surrounded by quotes ({\tt "}); {\tt sep} is
the field separator; {\tt eol} is the end-of-line separator; {\tt na} is the
string for missing values; use {\tt col.names=NA} to add a blank column header
to get the column headers aligned correctly for spreadsheet input}

\subsubsection{Clipboard}

On windows, the file connection can also be used with description =
"clipboard".

\cmdExmpl{x <- read.delim("clipboard")}{To read a table copied from Excel, use}
\cmdExmpl{\\ {\smalltt write.table(x,"clipboard",sep="\bs t",col.names=NA)}}{To write a table to the clipboard for Excel, use}

% http://people.debian.org/~kims/xclip/
Unix users wishing to write to the primary selection may be able to do so via
'xclip', for example by
\cmdExmpl{\\pipe('xclip -i', x)}	{writes data 'x' to clipboard}.

For database interaction, see packages {\tt RODBC}, {\tt DBI},\\
{\tt RMySQL}, {\tt RPgSQL}, and {\tt ROracle}. See packages {\tt XML},
{\tt hdf5}, {\tt netCDF} for reading other file formats.

\section{Generating, slicing and extracting data}{}
\subsection{Data creation}{}
\cmdS{c(...)}	{generic function to concatenate arguments with the default
forming a vector; with {\tt recursive=T} descends through lists combining all
elements into one vector}
\cmdS{from:to}	{generates a sequence; ``:'' has operator priority; 1:4 + 1 is
``2,3,4,5''}
\cmdS{seq(from,to)}	{generates a sequence {\tt by=} specifies increment; {\tt length=} specifies desired length}
\cmdS{seq(along=x)}	{generates {\tt 1, 2, \ldots, length(along)};\\useful for
{\tt for} loops}
\cmdS{rep(x,times)}	{replicate {\tt x} {\tt times}; use {\tt each=} to repeat ``each'' element of {\tt x} {\tt each} times;}
\cmdExmpl{1 2 3 1 2 3}{\tt rep(c(1,2,3),2)}
\cmdExmpl{1 1 2 2 3 3}{\tt rep(c(1,2,3),each=2)}
\cmdM{data.frame(...)}	{create a data frame of the named or unnamed arguments}
\cmdExmpl{\\d\ldots ame(v=1:4,ch=c("a","B","c","d"),n=10)}	{shorter vectors are being recycled to the length of the longest}
\cmdS{list(...)}	{create a list of the named or unnamed arguments }
\cmdExmpl{list(a=c(1,2),b="hi",c=3i)}{use}
\cmdM{array(x,dim=)}	{array with data {\tt x}; specify dimensions like {\tt dim=c(3,4,2)}; elements of {\tt x} recycle if {\tt x} is not long enough}
\cmdL{matrix(x,nrow=,ncol=)}	{matrix; elements of {\tt x} recycle}
\cmdL{factor(x,levels=)}	{encodes a vector {\tt x} as a factor}
\cmdL{gl(n,k,length=n*k,labels=1:n)}	{generate levels (factors) by specifying the pattern of their levels; {\tt k} is the number of levels, and {\tt n} is the number of replications}
\cmdM{expand.grid()}	{a data frame from all combinations of the supplied vectors or factors}

% Bind Rows/Columns to Matrices
\cmdS{rbind(...)}	{combine arguments by rows for matrices, data frames, and
others}
\cmdS{cbind(...)}	{id. by columns}
\cmdExmpl{cbind(x, colName=c(1,2,3))}	{append column named ``colName'' to matrix x}

\subsection{Indexing vectors}{}
\cmdOper{x[n] }	{ $ n^{th} $ element}
\cmdOper{x[-n] }	{all {\it but} the $ n^{th} $ element}
\cmdOper{x[-length(x)] }	{all {\it but last} element}
\cmdOper{x[1:n] }	{first elements}
\cmdOper{x[-(1:n)] }	{elements from {\tt n+1} to the end}
\cmdOper{x[c(1,4,2)] }	{specific elements}
\cmdOper{x["name"] }	{element named {\tt "name"}}
\cmdOper{x[x > 3] }	{all elements greater than 3}
\cmdOper{x[x > 3 \& x < 5] }	{all elements between 3 and 5}
\cmdExmpl{\\\tt x[x \%in\% c("a","and","the")] }	{elements in the given set}

\subsection{Indexing lists}{}
\cmdOper{x[n]}	{list with elements {\tt n}}
\cmdOper{x[[n]]}	{{\tt n}$^{th}$ element of the list}
\cmdOper{x[["name"]]}	{element of the list named {\tt "name"}}
\cmdOper{x\$name}	{id.}

\subsection{Indexing matrices}{}
\cmdOper{x[i,j]}	{element at row {\tt i}, column {\tt j}}
\cmdOper{x[i,]}	{row {\tt i}}
\cmdOper{x[,j]}	{column {\tt j}}
\cmdOper{x[,c(1,3)]}	{columns 1 and 3}
\cmdOper{x["name",]}	{row named {\tt "name"}}

\subsection{Indexing data frames}{matrix indexing plus the following}
\cmdOper{x[["name"]]}	{column named {\tt "name"}}
\cmdOper{x\$name}	{id.}

\section{Data selection and manipulation}{}
\subsection{Most common commands}{}
\cmdS{which.max(x)}	{ returns the index of the greatest element of $x$}
\cmdS{which.min(x)}	{ returns the index of the smallest element of $x$}
\cmdS{rev(x)}	{ reverses the elements of {\tt x}}
\cmdL{order(x), sort(x)}	{shows numerical order, sorts the elements of {\tt x} in increasing order}
\cmdExmpl{\tt rev(sort(x))}	{to sort in decreasing order}
\cmdM{cut(x,breaks)}	{divides {\tt x} into intervals (factors); {\tt breaks} is the number of cut intervals or a vector of cut points}
\cmdS{x \%in\% y}	{logical vector indicating if there is a match or not for its left operand\\}
\cmdS{match(x, y)}	{returns a vector of the same length than {\tt x}
    with the elements of {\tt x} which are in {\tt y} ({\tt NA}
    otherwise)}
\cmdM{which(x == a)}	{returns a vector of the indices of {\tt x} if the
comparison operation is true ($T$), in this example the values of {\tt i} for
which {\tt x[i] == a} (the argument of this function must be a variable of mode logical)}
\cmdS{choose(n, k)}	{ computes the combinations of $k$ events among $n$ repetitions = $n!/[(n-k)!k!]$}
\cmdS{combn(n, k)}	{ generate all combinations of n elements, taken m at a time.}
\cmdS{na.omit(x)}	{suppresses the observations with missing data ({\tt NA}) (suppresses the corresponding line if {\tt x} is a matrix or a data frame)}
\cmdL{complete.cases(x[$n$],x[$n$])}	{allows removement of `na's by using part of the dataframe} % http://stackoverflow.com/a/4862502
\cmdExmpl{\\ x[complete.cases(x[,5:6]),]}	{skip all rows in data frame x, where `na' appears in column 5 or 6}
\cmdS{na.fail(x)}	{returns an error message if {\tt x }contains at least one {\tt NA}}
\cmdS{unique(x)}	{if {\tt x} is a vector or a data frame, returns a similar object but with the duplicate elements suppressed}
\cmdM{duplicated(x)}	{returns a logical vector indicating which elements (rows) of a vector or data frame are duplicates}
\cmdS{table(x)}	{returns a table with the numbers of the differents values of {\tt x} (typically for integers or factors)}
\cmdL{subset(x, subset, select)}	{returns a selection of {\tt x} with respect to criteria, typically comparisons: {\tt x\$V1 < 10}}
\cmdExmpl{combine more than one subset argument with logical operators.}	{subset(x, Temp > 80 \& Temp < 120, \ldots)}
\cmdExmpl{if {\tt x} is a data frame, the option {\tt select} gives the variables to be kept (or dropped, using a minus sign).}	{select}
\cmdM{sample(x, size)}	{resample randomly and without replacement {\tt size}
elements in the vector {\tt x}, the option {\tt replace = TRUE} allows to
resample with replacement}
\cmdL{prop.table(x,margin=)}	{table entries as fraction of marginal table}

\subsection{Variable information}{is.na(x), is.null(x), is.array(x), is.data.frame(x), \ldots}
\cmdS{methods(is)}	{list all available typetests}
\cmdS{methods(as)}	{list of all variable conversions}
\cmdS{any(x)}	{any TRUE elements of {\tt x}?}
\cmdS{all(x)}	{all TRUE elements of {\tt x}?}
\cmdS{length(x)}	{ number of elements in {\tt x}}
% see: http://stackoverflow.com/a/18969751/3569509
\cmdS{rle(x)}	{length of consecutive elements in {\tt x}}
\cmdS{dim(x)}	{Retrieve or set the dimension of an object; {\tt dim(x) <- c(3,2)}}
\cmdS{dimnames(x)}	{Retrieve or set the dimension names of an object}
\cmdS{nrow(x)}	{number of rows; {\tt NROW(x)} is the same but treats a vector as a one-row matrix}
\cmdS{ncol(x)}	{and}
\cmdS{NCOL(x)}	{id. for columns}
\cmdS{class(x)}	{get or set the class of {\tt x}; {\tt class(x) <- "myclass"}}
\cmdS{unclass(x)}	{remove the class attribute of {\tt x}}
\cmdM{attr(x,which)}	{get or set the attribute {\tt which} of {\tt x}}
\cmdM{attributes(x)}	{get or set the list of attributes of {\tt x}}

\subsection{Characters (Strings)}{}
\cmdS{paste(...)}	{concatenate vectors after converting to character; {\tt sep=} is the string to separate terms (a single space is the default); {\tt collapse=} is an optional string to separate ``collapsed'' results}
\cmdL{substr(x,start,stop)}	{substrings in a character vector}
\cmdExmpl{\\substr(x, start, stop) <- value}	{can also assign, as}
\cmdL{strsplit(x,split)}	{split {\tt x} according to the substring {\tt split}}
\cmdM{grep(pattern,x)}	{searches for matches to {\tt pattern} within {\tt x}; see {\tt ?regex}}
\cmdL{gsub(pattern,replacement,x)}	{replacement of matches determined by regular expression matching {\tt sub()} is the same but only replaces the first occurrence.}
\cmdS{tolower(x)}	{convert to lowercase}
\cmdS{toupper(x)}	{convert to uppercase}
\cmdM{pmatch(x,table)}	{partial matches for the elements of {\tt x} among {\tt table}}
\cmdS{nchar(x)}	{number of characters}
\cmdS{assign}	{assign a value to a name}
\cmdS{get}	{get a value from a name}
\cmdL{eval(parse(text='1+1'))}	{compute on the language!!}
\cmdL{type.convert(x, na.strings, as.is, dec)}	{convert object attributes}
\cmdOpt{na.strings}	{\\ what to do with missing data ("NA")}
\cmdOpt{as.is}	{if TRUE: strings, else: factors}
\cmdOpt{dec}	{decimal specifier: '.' or ','}
\cmdOpt{numerals}	{\\"allow.loss","warn.loss","no.loss"}
\cmdExmpl{type.convert(dax, na.strings = "NA", as.is = TRUE, dec = ",")}	{convert from character to numerical vector}

\section{Dates and Times}{
The class {\tt Date} has dates without times.  {\tt POSIXct} has
dates and times, including time zones. Comparisons (e.g. $>$),
{\tt seq()}, and {\tt difftime()} are useful. {\tt Date} also allows
$+$ and $-$. {\tt ?DateTimeClasses} gives more information. See also package
{\tt chron}.}

\cmdS{as.Date(s)}	{and}

% POSIXlt vs. POSIXct vs. strptime: http://stackoverflow.com/a/10700025/3569509
\cmdM{as.POSIXct(s)}	{convert to the respective class; {\tt format(dt)} converts to a string representation. The default string format is ``2001-02-21''. These accept a second argument to specify a format for conversion. Some common formats are:}
\cmdOper{\%a, \%A}	{Abbreviated and full \\weekday name.}
\cmdOper{\%b, \%B}	{Abbreviated and full month name.}
\cmdOper{\%d}	{Day of the month (01--31).}
\cmdOper{\%H}	{Hours (00--23).}
\cmdOper{\%I}	{Hours (01--12).}
\cmdOper{\%j}	{Day of year (001--366).}
\cmdOper{\%m}	{Month (01--12).}
\cmdOper{\%M}	{Minute (00--59).}
\cmdOper{\%p}	{AM/PM indicator. }
\cmdOper{\%S}	{Second as decimal number (00--61).}
\cmdOper{\%U}	{Week (00--53); the first Sunday as day 1 of week 1.}
\cmdOper{\%w}	{Weekday (0--6, Sunday is 0).}
\cmdOper{\%W}	{Week (00--53); the first Monday as day 1 of week 1.}
\cmdOper{\%X}	{Same as ``\%Y-\%m-\%d''}
\cmdOper{\%y}	{Year without century (00--99).\\(Don't use due to ambiguousness!)}
\cmdOper{\%Y}	{Year with century.}
\cmdOper{\%z}	{(output only.) Offset from Greenwich; {\tt -0800} is 8 hours west of.}
\cmdOper{\%Z}	{(output only.) Time zone as a character
    string (empty if not available).}

Where leading zeros are shown they will be used on output but are
optional on input. See {\tt ?strftime}.

{\tt as.POSIXct( strptime( , format= ) )\\
    format()}\\

Setting the C locale will overcome NA issues which emerge on some systems due
to format incongruencies:

{\tt lct <- Sys.getlocale(`LC\_TIME')\\
Sys.setlocale(`LC\_TIME', `C')\\
x <- "1919-01-31"\\
as.Date(x,...)\\
...\\
Sys.setlocale(`LC\_TIME', lct)
}

\section{Math}{{\tt sin,cos,tan,asin,acos,atan,atan2,log,log10,exp}}

\subsection{Basic Math Operations}{}
\cmdS{\%\%, \%/\%}	{modulo/quotient, remainder}
\cmdS{max(x)}	{ maximum of the elements of {\tt x}}
\cmdS{min(x)}	{ minimum of the elements of {\tt x}}
\cmdS{range(x)}	{ id. then {\tt c(min(x), max(x))}}
\cmdS{sum(x)}	{ sum of the elements of {\tt x}}
\cmdL{Mod(x)\or abs(x)}	{absolute value of $x$}
\cmdS{diff(x)}	{ lagged and iterated differences of vector {\tt x}}
\cmdS{prod(x)}	{ product of the elements of {\tt x}}
\cmdS{mean(x)}	{ mean of the elements of {\tt x}}
\cmdS{median(x)}	{ median of the elements of {\tt x}}
\cmdL{quantile(x,probs=)}	{sample quantiles corresponding to given
    probabilities (default: 0,.25,.5,.75,1)}
\cmdL{weighted.mean(x, w)}	{mean of {\tt x} with weights {\tt w}}
\cmdS{rank(x)}	{ ranks of the elements of {\tt x}}
\cmdM{var(x)\or cov(x)}	{variance of the elements of {\tt x}
    (calculated on $n-1$); if {\tt x} is a matrix or a data frame, the
    variance-covariance matrix is calculated}
\cmdS{sd(x)}	{standard deviation of {\tt x}}
\cmdS{cor(x)}	{correlation matrix of {\tt x} if it is a matrix or a data frame (1 if {\tt x} is a vector)}
\cmdS{acf(x)}	{Computes (and by default plots) estimates of the autocovariance or autocorrelation function}
\cmdL{var(x, y)\or {\tt cov(x, y)}}	{covariance between {\tt x} and {\tt y}, or between the columns of {\tt x} and those of {\tt y} if they are matrices or data frames}
\cmdS{cor(x, y)}	{linear correlation between {\tt x} and {\tt y}, or correlation matrix if they are matrices or data frames}
\cmdS{round(x, n)}	{rounds the elements of {\tt x} to {\tt n} decimals}
\cmdM{log(x, base)}	{computes the logarithm of {\tt x} with base {\tt base}}
\cmdS{scale(x)}	{if {\tt x} is a matrix, centers and reduces the data; to
center only use the option {\tt center=F}, to reduce only {\tt scale=F}
(by default {\tt center=T, scale=T})}
\cmdS{pmin(x,y,\ldots)}	{ a vector which $i$th element is the minimum of {\tt x[i]}, {\tt y[i]}, \ldots}
\cmdS{pmax(x,y,\ldots)}	{ id. for the maximum}
\cmdS{cumsum(x)}	{a vector which $i$th element is the sum from {\tt x[1]} to {\tt x[i]}}
\cmdS{cumprod(x)}	{ id. for the product}
\cmdS{cummin(x)}	{ id. for the minimum}
\cmdS{cummax(x)}	{ id. for the maximum}

\subsection{Arithmetic \& Boolean Operators}{}
\cmdOper{x + y}	{addition}
\cmdOper{x - y}	{subtraction}
\cmdOper{x * y}	{multiplication}
\cmdOper{x / y}	{division}
\cmdOper{x \expon\ y}	{exponentiation}
\cmdOper{x \%\% y}	{modular arithmetic}
\cmdOper{x \%/\% y}	{integer division}
\cmdOper{X \%*\% Y}	{matrix multiplication}
\cmdOper{x == y}	{test for equality}
\cmdOper{x != y}	{test for inequality}
\cmdOper{x <= y}	{test for less-than-or-equal}
\cmdOper{x >= y}	{test for greater-than-or-equal}
\cmdOper{x \&\& y}	{boolean {\tt and} for scalars}
\cmdOper{x || y}	{boolean {\tt or} for scalars}
\cmdOper{x \& y}	{boolean {\tt and} for vectors (vector x,y,result)}
\cmdOper{x | y}	{boolean {\tt or} for vectors\\(vector x,y,result)}
\cmdOper{!x}	{boolean negation}

\subsection{Complex Numbers}{{\smalltt union(x,y),  intersect(x,y),  setdiff(x,y),  setequal(x,y)}}
\cmdL{is.element(el,set)}	{``set'' functions}
\cmdS{Re(x)}	{real part of a complex number}
\cmdS{Im(x)}	{imaginary part}
\cmdS{Arg(x)}	{angle in radians of the complex number}
\cmdS{Conj(x)}	{complex conjugate}
\cmdM{convolve(x,y)}	{compute the several kinds of convolutions of two sequences}
\cmdS{fft(x)}	{Fast Fourier Transform of an array}
\cmdS{mvfft(x)}	{FFT of each column of a matrix}

Many math functions have a logical parameter {\tt na.rm=F} to
specify missing data (NA) removal.

\subsection{Matrices}{}
\cmdS{\%o\%, outer()}	{outer products on arrays}
\cmdS{A\ \%*\%\ B}	{multiplication of A and B}
\cmdS{kronecker()}	{kronecker products on arrays}
\cmdExmpl{kronecker(A,solve(A))}	{Kronecker product of A with her own inverted matrix}
\cmdS{t(x)}	{transpose}
\cmdS{diag(x)}	{diagonal}
\cmdS{det(a)}	{matrix determinant of {\tt a}}
\cmdS{solve(a,b)}	{solves {\tt a \%*\% x = b} for {\tt x}}
\cmdS{solve(a)}	{matrix inverse of {\tt a}}
\cmdS{rowsum(x)}	{sum of rows for a matrix-like object;}
\cmdS{rowSums(x)}	{is a faster version}
\cmdS{colsum(x)}	{sum of columns for a matrix-like object;}
\cmdS{colSums(x)}	{id. for columns}
\cmdS{rowMeans(x)}	{fast version of row means}
\cmdS{colMeans(x)}	{id. for columns}

\section{Advanced data processing and HOFs}{}
% see: http://stackoverflow.com/a/7141669/3569509
\subsection{Apply functions to elements}{The following section covers the most
common commands: l$apply$ as well as $apply$ itself. Regarding the
missing functions [m,r,s,t,v]$apply$ consult the R-help pages. The base apply
family of function is standardized and parallelized by the {\tt plyr} package.}
\cmdL{by(data,INDEX,FUN)}	{apply {\tt FUN} to data frame {\tt data} subsetted by {\tt INDEX}}
\cmdM{lapply(X,FUN)}	{apply {\tt FUN} to each element of the list {\tt X}}
\cmdL{apply(X,INDEX,FUN=)}	{a vector, array or list of values obtained by applying a function {\tt FUN} to margins ({\tt INDEX}) of {\tt X}}
\subsubsection{Options for INDEX}
\cmdOper{1}	{apply FUN to array's rows}
\cmdOper{2}	{apply FUN to array's columns}

\subsection{The 6 common higher-order functions}{}
\cmdL{Reduce(f, x, init, right = F, accumulate = F)}{}
\cmdL{Filter(f, x)}{}
\cmdL{Find(f, x, right = F, nomatch = NULL)}{}
\cmdL{Map(f, \ldots)}{}
\cmdL{Negate(f)}{}
\cmdL{Position(f,x,right = F,nomatch = NA\_integer\_)}{}

\subsection{Others}{}
\cmdS{optimise()}	{One Dimensional Optimization}
\cmdS{merge(a,b)}	{merge two data frames by com\-mon col\-umns or row names}
\cmdL{xtabs(a~b,data=x)}	{a contingency table from cross-classi\-fy\-ing factors}
\cmdL{aggregate(x,by,FUN)}	{splits the data frame {\tt x} into subsets,
computes summary statistics for each, and returns the result in a convenient
form; {\tt by} is a list of grouping elements, each as long as the variables in
{\tt x}}
\cmdS{stack(x, \ldots)}	{transform data available as se\-pa\-rate col\-umns in
a data frame or list into a single column}
\cmdM{unstack(x, \ldots)}	{inverse of {\tt stack()}}
\cmdM{reshape(x, \ldots)}	{reshapes a data frame between 'wide' format
    with re\-pea\-ted mea\-sure\-ments in separate
    columns of the same record and 'long' format in separate records}
\cmdExmpl{ \code(direction="wide") or\\ \code(direction="long")}	{use}

\section{Optimization and model fitting}{}
\cmdL{optim(par, fn, method = c("Nelder-Mead", "BFGS", \ldots)}{general purpose
optimization; {\tt par} is initial values, {\tt fn} is function to optimize
(normally minimize)}
\cmdS{nlm(f,p)}	{minimize function {\tt f} using a Newton-type algorithm with
starting values {\tt p}}
\cmdS{lm(formula)}	{fit linear models; {\tt formula} is typically of the form
{\tt response \tild\ termA + termB + \ldots + termN}}
\cmdExmpl{\tt I(x*y) + I(x\^{}2)}	{for terms made of nonlinear components, use}

\cmdL{glm(formula,family=)}	{fit generalized linear models, specified by giving
a symbolic description of the linear predictor and a description of the error
distribution}
\cmdExmpl{{\tt family} is a description of the error distribution and link
    function to be used in the model}	{see {\tt ?family}}
\cmdM{nls(formula)}	{nonlinear least-squares estimates of the nonlinear model
parameters}
\cmdM{approx(x,y=)}	{linearly interpolate given data points; {\tt x} can be an
xy plotting structure}
\cmdM{spline(x,y=)}	{cubic spline interpolation}
\cmdM{loess(formula)}	{fit a polynomial surface using local fitting}

Many of the formula-based modeling functions have several common
arguments: {\tt data=} the data frame for the formula variables,
{\tt subset=} a subset of variables used in the fit,
{\tt na.action=} action for missing values:\\{\tt "na.fail"}, {\tt "na.omit"}, or
a function.

\section{Statistics}{help.search("test") gives you a range of validity tests
such as {\tt t.test(), binom.test(), prop.test(),\\power.t.test(),
pairwise.t.test(), \ldots}}
\subsection{Model Analysis}	{The following generics often apply to model fitting functions}
\cmdM{predict(fit,...)}	{predictions from {\tt fit} based on input data}
\cmdS{coef(fit)}	{ returns the estimated coefficients (sometimes with their standard-errors)}
\cmdM{residuals(fit)}	{ returns the residuals}
\cmdM{df.residual(fit)}	{ returns the number of residual degrees of freedom}
\cmdM{deviance(fit)}	{ returns the deviance}
\cmdS{fitted(fit)}	{ returns the fitted values}
\cmdS{logLik(fit)}	{ computes the logarithm of the likelihood and the number of parameters}
\cmdS{AIC(fit)}	{ computes the Akaike information criterion or AIC}
\cmdS{aov(formula)}	{analysis of variance model}
\cmdM{anova(fit,...)}	{analysis of variance (or deviance) tables for one or more fitted model objects}
\cmdS{density(x)}	{kernel density estimates of {\tt x}}

\section{Distribution Functions}{All of the following commands can be used by
replacing the letter {\tt r} with {\tt d}, {\tt p} or {\tt q} to get the
probability density, the cumulative probability density, and the value of
quantile, respectively.}

\cmdS{{\tt d{\it func}(x, \ldots)}}{Cumulative Density Function}
\cmdS{{\tt p{\it func}(q, \ldots)}}{Probability Distribution Function}
\cmdS{{\tt q{\it func}(p, \ldots)}}{Quantile Function}
\cmdExmpl{with 0 $<$ {\tt p} $<$ 1}{prob.}
\cmdS{{\tt r{\it func}(n, \ldots)}}{Random generated Function}

\subsection{Student-t}{Density $dt(x, df, ncp)$, distribution function
$pt(\ldots)$, quantile function $qt(\ldots)$ and random generation $rt(\ldots)$
for the $t$ distribution with $df$ degrees of freedom (and optional
non-centrality parameter ncp).}

\subsection{Normally Distributed}{}
\cmdM{Gaussian}{rnorm(n, mean=0, sd=1)}
\cmdM{exponential}{rexp(n, rate=1)}
\cmdM{gamma}{rgamma(n, shape, scale=1)}
\cmdM{Poisson}{rpois(n, lambda)}
\cmdM{Weibull}{rweibull(n, shape, scale=1)}
\cmdM{Cauchy}{rcauchy(n, location=0, scale=1)}
\cmdM{beta}{rbeta(n, shape1, shape2)}
\cmdM{`Student'-$t$}{rt(n, df)}
\cmdM{Fisher-Snedecor}{rf(n, df1, df2)}
\cmdExmpl{}	{($F$)($\chi^2$)}
\cmdM{Pearson}{rchisq(n, df)}
\cmdM{geometric}{rgeom(n, prob)}
\cmdM{hypergeometric}{rhyper(nn, m, n, k)}
\cmdM{logistic}{rlogis(n, location=0, scale=1) }
\cmdM{lognormal}{rlnorm(n, meanlog=0, sdlog=1)}
\cmdM{uniform}{runif(n, min=0, max=1)}
\subsection{Wilcoxon's statistics}{}
\cmdL{rwilcox(nn, m, n)}{Wilcoxon Statistic}
\cmdM{rsignrank(nn, n)}{Signed Rank Statistic}
\subsection{Binomial Distributed}{}
\cmdL{rbinom(n, size, prob)}{positive binomial}
\cmdL{rnbinom(n, size, prob)}{negative binomial}

\section{Time Series Calculations}{}
\cmdL{ts(x, start, end, frequency)}	{Create a time-series vector}
\cmdL{xts(x, order.by=as.POSIXct(\ldots))}	{Convert data vector to a timeseries-object}
\cmdL{ar(x, order.max, method)}	{fit an autoregressive time series model to the data}
\cmdExmpl{ar(data, order.max = 1, method = "ols")}	{fit an AR(1) to $data$ via
    an OLS regression}
\cmdS{window(x)}	{Extracts the subset of the object x observed between the
    times start and end. If a frequency is specified, the series is then re-sampled
    at the new frequency}
\cmdExmpl{\\ window(x, start=c(1901, 11), frequency=T)}	{Resampling a timeseries for
    every 11th entry eg. monthly data}
\cmdS{time(x)}	{creates the vector of times at which a time series was sampled}
\cmdS{cycle(x)}	{gives the positions in the cycle of each observation}
\cmdS{frequency(x)}	{returns the number of samples per unit time and deltat the
    time interval between observations}
\cmdL{filter(x,filter)}	{applies linear filtering to a univariate time series
    or to each series separately of a multivariate time series}
\cmdL{Box.test(x, lag = p, type = c())}	{Compute the `Box--Pierce' or `Ljung--Box'
test statistic for examining the null hypothesis of independence in a given
time series.}
\cmdOper{Box-Pierce}	{$T\ast sum(rho[i]^2)$}
\cmdOper{Ljung-Box}	{$T(T+2)\ast sum(rho[i]^2/(T-j))$}

\section{Plotting}{}
\cmdS{plot(x)}	{plot of the values of {\tt x} (on the $y$-axis) ordered on the
$x$-axis}
\cmdS{plot(x, y)}	{bivariate plot of {\tt x} (on the $x$-axis) and {\tt y}
(on the $y$-axis)}
\cmdS{hist(x)}	{histogram of the frequencies of {\tt x}}
\cmdS{barplot(x)}	{histogram of the values of {\tt x}; use {\tt horiz=F} for
horizontal bars}
\cmdS{curve(x)}	{draws a curve corresponding to a function over the interval
[from, to].}
\cmdS{dotchart(x)}	{if {\tt x} is a data frame, plots a Cleveland dot plot
(stacked plots line-by-line and column-by-column)}
\cmdS{pie(x)}	{ circular pie-chart}
\cmdS{boxplot(x)}	{ ``box-and-whiskers'' plot}
\cmdL{sunflowerplot(x, y)}	{id. than {\tt plot()} but the points with similar
coordinates are drawn as flowers which petal number represents the number of
points}
\cmdS{stripplot(x)}	{plot of the values of {\tt x} on a line (an alternative to
{\tt boxplot()} for small sample sizes)}
\cmdM{coplot(x\~{}$\mid$ z)}	{bivariate plot of {\tt x} and {\tt y} for each
value or interval of values of {\tt z}}
\cmdL{interaction.plot (f1, f2, y)}	{if {\tt f1} and {\tt f2} are factors,
plots the means of {\tt y} (on the $y$-axis) with respect to the values of {\tt
f1} (on the $x$-axis) and of {\tt f2} (different curves); the option {\tt fun}
allows to choose the summary statistic of {\tt y} (by default {\tt fun=mean})}
\cmdM{matplot(x,y)}	{bivariate plot of the first column of {\tt x} {\it vs.}
the first one of {\tt y}, the second one of {\tt x} {\it vs.} the second one of
{\tt y}, etc.}
\cmdM{fourfoldplot(x)}	{visualizes, with quarters of circles, the association
between two dichotomous variables for different populations ({\tt x} must be an
array with {\tt dim=c(2, 2, k)}, or a matrix with {\tt dim=c(2, 2)} if $k=1$)}
\cmdM{assocplot(x)}	{ Cohen--Friendly graph showing the deviations  from
independence of rows and columns in a two dimensional contingency table}
\cmdM{mosaicplot(x)}	{ `mosaic' graph of the residuals from a log-linear
regression of a contingency table}
\cmdS{pairs(x)}	{if {\tt x} is a matrix or a data frame, draws all possible
bivariate plots between the columns of {\tt x}}
\cmdS{plot.ts(x)}	{if {\tt x} is an object of class {\tt "ts"}, plot of {\tt
x} with respect to time, {\tt x}  may be multivariate but the series must have
the same frequency and dates}
\cmdS{ts.plot(x)}	{id. but if {\tt x} is multivariate the series may have
different dates and must have the same frequency}
\cmdS{qqnorm(x)}	{quantiles of {\tt x} with respect to the values expected
under a normal law}
\cmdM{qqplot(x, y)}	{quantiles of {\tt y} with respect to the quantiles of {\tt
x}}
\cmdL{contour(x, y, z)}	{contour plot (data are interpolated to draw the
curves), {\tt x} and {\tt y} must be vectors and {\tt z} must be a matrix so
that {\tt dim(z)=c(length(x), length(y))} ({\tt x} and {\tt y} may be omitted)}
\cmdL{filled.contour(x, y, z)}	{ id. but the areas between the contours are
coloured, and a legend of the colours is drawn as well}
\cmdM{image(x, y, z)}	{ id. but with colours (actual data are plotted)}
\cmdM{persp(x, y, z)}	{ id. but in perspective (actual data are plotted)}
\cmdL{stars(x)}	{if {\tt x} is a matrix or a data frame, draws a graph with
segments or a star where each row of {\tt x} is represented by a star and the
columns are the lengths of the segments}
\cmdL{symbols(x, y, \ldots)}	{draws, at the coordinates given by {\tt x} and
{\tt y}, symbols (circles, squares, rectangles, stars, thermometres or
``boxplots'') which sizes, colours \ldots{} are specified by supplementary
arguments}
\cmdL{termplot(mod.obj)}	{ plot of the (partial) effects of a regression
model ({\tt mod.obj})}

\subsection{Plot Modifiers}{The following parameters are common to many
    plotting functions}

\cmdOper{add=F}	{if \T superposes the plot on the previous one (if it exists)}
\cmdOper{axes=T}	{if \F does not draw the axes and the box}
\cmdOper{type="p"}	{ specifies the type of plot, {\tt "p"}: points, {\tt "l"}:
lines, {\tt "b"}: points connected by lines, {\tt "o"}: id. but the lines are
over the points, {\tt "h"}: vertical lines, {\tt "s"}: steps, the data are
represented by the top of the vertical lines, {\tt "S"}: id. but the data are
represented by the bottom of the vertical lines}
\cmdOper{xlim=, ylim=}	{specifies the lower and upper limits of the axes, for
example with {\tt xlim=c(1, 10)} or {\tt xlim=range(x)}}
\cmdOper{xlab=, ylab=}	{ annotates the axes, must be variables of mode character}
\cmdOper{main=}	{ main title, must be a variable of mode character}
\cmdOper{sub=}	{ sub-title (written in a smaller font)}

\subsection{Low-level plotting commands}{}
\cmdS{dev.new()}	{open a new graphics device (typically a window). see similar in help.}
\cmdM{graphics.off()}	{closes before opened plot. it is implemented by
calling $dev.off()$ as many times as necessary.}
\cmdExmpl{rgl.close(), iplot.off()}	{equvialent commands for $rgl$, $iplots$ packages}
\cmdM{points(x, y)}	{adds points (the option {\tt type=} can be used)}
\cmdS{lines(x, y)}	{ id. but with lines}
\cmdL{text(x, y, labels...)}	{ adds text given by {\tt labels} at
coordinates ({\tt x},{\tt y}); a typical use is: {\tt plot(x, y, type="n");
text(x, y, names)}}
\cmdL{mtext(text, side=3, line=0, \ldots)}	{adds text given by {\tt text} in
the margin specified by {\tt side} (see {\tt axis()} below); {\tt line}
specifies the line from the plotting area}
\cmdL{segments(x0, y0, x1, y1)}	{ draws lines from points ({\tt x0},{\tt y0})
to points ({\tt x1},{\tt y1})}
\cmdL{arrows(x0, y0, x1, y1, angle= 30, code=2)}	{id. with arrows at points
({\tt x0},{\tt y0}) if {\tt code=2}, at points ({\tt x1},{\tt y1}) if {\tt
code=1}, or both if {\tt code=3}; {\tt angle} controls the angle from the shaft
of the arrow to the edge of the arrow head}
\cmdM{abline(a,b)}	{draws a line of slope {\tt b} and intercept {\tt a}}
\cmdM{abline(h=y)}	{ draws a horizontal line at ordinate {\tt y}}
\cmdM{abline(v=x)}	{ draws a vertical line at abcissa {\tt x}}
\cmdM{abline(lm.obj)}	{ draws regression line given by {\tt lm.obj}}
\cmdL{rect(x1, y1, x2, y2)}	{ draws a rectangle which left, right, bottom, and
top limits are {\tt x1}, {\tt x2}, {\tt y1}, and {\tt y2}, respectively}
\cmdM{polygon(x, y)}	{draws a polygon linking the points with coordinates
given by {\tt x} and {\tt y}}
\cmdL{legend(x, y, legend)}	{ adds the legend at the point ({\tt x,y})
with the symbols given by {\tt legend}. You may as well add {\tt "bottom",
"topleft"} etc. in place of coordinates {\tt x,y} manually}
\cmdS{title()}	{ adds a title and optionally a sub-title}
\cmdM{axis(side, vect)}	{adds an axis at the bottom ({\tt side=1}), on the left
({\tt 2}), at the top ({\tt 3}), or on the right ({\tt 4}); {\tt vect}
(optional) gives the abcissa (or ordinates) where tick-marks are drawn}
\cmdS{rug(x)}	{draws the data {\tt x} on the $x$-axis as small vertical lines}
\cmdL{locator(n, type="n", \ldots)}	{returns the coordinates ($x,y$) after the
user has clicked {\tt n} times on the plot with the mouse; also draws
symbols ({\tt type="p"}) or lines ({\tt type="l"}) with respect to optional
graphic parameters ({\tt \ldots})}
\cmdExmpl{type="n"}{by default nothing is drawn}

\subsection{Graphical parameters}{These can be set globally with {\tt par(...)}; many can be passed as
parameters to plotting commands.}
\cmdS{adj}	{controls text justification ({\tt 0} left-justified, {\tt 0.5}
centred, {\tt 1} right-justified)}
\cmdS{bg}	{specifies the colour of the background (ex. : {\tt bg="red"}, {\tt
bg="blue"}, \ldots{} the list of the 657 available colours is displayed with
{\tt colors()})}
\cmdS{bty}	{controls the type of box drawn around the plot, allowed values
    are: {\tt "o"}, {\tt "l"}, {\tt "7"}, {\tt "c"}, {\tt "u"} or {\tt "]"} (the box looks like the corresponding character)}
\cmdExmpl{the box is not drawn}{if {\tt bty="n"}}
\cmdS{cex}	{ a value controlling the size of texts and symbols with respect to
the default; the following parameters have the same control for numbers on the
axes,\\
    {\tt cex.axis}, the axis labels, {\tt cex.lab}, the title, {\tt cex.main},
    and the sub-title, {\tt cex.sub}}
\cmdS{col}	{controls the color of symbols and lines; use color names e.g. "red", "blue" or as "\#RRGGBB"}
\cmdExmpl{colors(), rgb(), hsv(), gray() and rainbow()}{see}
\cmdExmpl{col.axis, col.lab, col.main, col.sub}{as for {\tt cex} there are}
\cmdS{font}	{an integer which controls the style of text ({\tt 1}: normal, {\tt
2}: italics, {\tt 3}: bold, {\tt 4}: bold italics)}
\cmdExmpl{font.axis, font.lab, font.main, font.sub}{as for cex there are}
\cmdS{las}	{ an integer which controls the orientation of the axis labels ({\tt 0}: parallel to the axes, {\tt 1}: horizontal, {\tt 2}: perpendicular to the axes, {\tt 3}: vertical)}
\cmdS{lty}	{controls the type of lines, can be an integer or string ({\tt 1}:
{\tt "solid"}, {\tt 2}: {\tt "dashed"}, {\tt 3}: {\tt "dotted"}, {\tt 4}: {\tt
"dotdash"}, {\tt 5}: {\tt "longdash"}, {\tt 6}: {\tt "twodash"}, or a string of
up to eight characters (between {\tt "0"} and {\tt "9"}) which specifies
alternatively the length, in points or pixels, of the drawn elements and the
blanks, for example {\tt lty="44"} will have the same effect than {\tt lty=2}}
\cmdS{lwd}	{ a numeric which controls the width of lines, default {\tt 1}}
\cmdS{mar}	{ a vector of 4 numeric values which control the space between the
axes and the border of the graph of the form {\tt c(bottom, left, top, right)},
the default values are {\tt c(5.1, 4.1, 4.1, 2.1)}}
\cmdS{mfcol}	{a vector of the form {\tt c(nr,nc)} which partitions the
graphic window as a matrix of {\tt nr} lines and {\tt nc} columns, the plots
are then drawn in columns}
\cmdS{mfrow}	{ id. but the plots are drawn by row}
\cmdS{pch}	{ controls the type of symbol, either an integer between 1 and 25,
or any single character within {\tt ""}}
% \sSmepage\includegraphics[width=8.5cm]{pch_symbol}
% \sSmepage\includegraphics[draft]{pch_symbol}

\cmdS{ps}	{ an integer which controls the size in points of texts and symbols}
\cmdS{pty}	{ a character which specifies the type of the plotting region, {\tt
"s"}: square, {\tt "m"}: maximal}
\cmdS{tck}	{a value which specifies the length of tick-marks on the axes as a
fraction of the smallest of the width or height of the plot; if {\tt tck=1} a
grid is drawn}
\cmdS{tcl}	{ a value which specifies the length of tick-marks on the axes as a fraction of the height of a line of text (by default {\tt tcl=-0.5})}
\cmdS{xaxt}	{if {\tt xaxt="n"} the $x$-axis is set but not drawn (useful in
    conjonction with\\
    {\tt axis(side=1, \ldots)})}
\cmdS{yaxt}	{if {\tt yaxt="n"} the $y$-axis is set but not drawn (useful in
conjonction \\with {\tt axis(side=2, \ldots)})}

\subsection{Lattice (Trellis) graphics}{ Use {\tt panel=} to define a custom panel
    function (see {\tt apropos("panel")} and {\tt ?llines}). Lattice functions
    return an object of class trellis and have to be {\tt print}ed to produce
    the graph. Use {\tt print(xyplot(...))} inside functions where automatic
    printing doesn't work. Use {\tt lattice.theme} and {\tt lset} to change
    Lattice defaults.}
\cmdS{xyplot(y\~{}x)}	{ bivariate plots (with many functionalities)}
\cmdM{barchart(y\~{}x)}	{  histogram of the values of {\tt y} with respect to those of {\tt x}}
\cmdM{dotplot(y\~{}x)}	{ Cleveland dot plot (stacked plots line-by-line and
column-by-column)}
\cmdM{densityplot(\~{}x)}	{ density functions plot}
\cmdM{histogram(\~{}x)}	{ histogram of the frequencies of {\tt x}}
\cmdS{bwplot(y\~{}x)}	{ ``box-and-whiskers'' plot}
\cmdS{qqmath(\~{}x)}	{  quantiles of {\tt x} with respect to the values
expected under a theoretical distribution}

\cmdM{stripplot(y\~{}x)}	{  single dimension plot, {\tt x} must be numeric, {\tt y} may be a factor}
\cmdS{qq(y\~{}x)}	{quantiles to compare two distributions, {\tt x} must be
numeric, {\tt y} may be numeric, character, or factor but must have two
`levels'}
\cmdS{splom(\~{}x)}	{ matrix of bivariate plots}
\cmdM{parallel(\~{}x)}	{ parallel coordinates plot}
\cmdL{levelplot(z\~{}x*y|g1*g2)}	{coloured plot of the values of {\tt z} at
the coordinates given by {\tt x} and {\tt y} ({\tt x}, {\tt y} and {\tt z} are
all of the same length)}
\cmdL{wireframe(z\~{}x*y|g1*g2)}	{ 3d surface plot}
\cmdL{cloud(z\~{}x*y|g1*g2)}	{ 3d scatter plot}

In the normal Lattice formula, {\tt y~x|g1*g2} has
combinations of optional conditioning variables {\tt g1} and {\tt g2} plotted
on separate panels. Lattice functions take many of the same arguments as base
graphics plus also {\tt data=} the data frame for the formula variables and
{\tt subset=} for subsetting.

\section{Programming}{ Use curly braces $\lbrace\rbrace$ around statements }
{\tt function( arglist ) expr \# function definition\\ return(value) if(cond)
    expr\\ if(cond) cons.expr else  alt.expr\\ for(var in seq) expr\\
    while(cond) expr\\ repeat expr\\ break\\ next\\ }

\cmdL{ifelse(test, yes, no)}	{a value with the same shape as {\tt test}
filled with elements from either {\tt yes} or {\tt no}}
\cmdL{do.call(funname, args)}	{executes a function call from the name of the
function and a list of arguments to be passed to it}

%% Footer
\copyrightnotice

% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
