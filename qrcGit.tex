%%%%%%%%%%%%%%
%  preamble  %
%%%%%%%%%%%%%%
% TeX Format

% version
\def\content{\uppercase{git}}
\def\shortcontent{\content}
\def\versionnumber{1.2}  % Version of this reference card
\def\version{v\versionnumber\ \month\ \year}

% include stylefile
\input mydefs.sty
\mytitle

% shortcopyrightnotice
\shortintro

%%%%%%%%%%%%%%%%%%
%  card content  %
%%%%%%%%%%%%%%%%%%
\section{Main commands}{}
\cmdS{add}	{Add file contents to the index}
\cmdOpt{A [:/]}	{adds all file changes including deletions to the staging area [for the whole tree]}
\cmdOpt{f}	{allow adding otherwise ignored files}
\cmdOpt{p}	{choose hunks of patch between the index and the work tree and add them to the index}
\cmdS{am}	{Apply a series of patches from a mailbox}
\cmdS{archive}	{Create an archive of files from a named tree}
\cmdS{bisect}	{Find by binary search the change that introduced a bug}
\cmdExmpl{bisect run test -f $file.txt$}	{search for existence of $file$ in last commits}
\cmdS{branch}	{List, create, or delete branches}
\cmdOpt{a}	{lists all branches including the remote branches}
\cmdOpt{d}	{delete {\tt \dots branch}}
\cmdOpt{m}	{rename branch: \dots {\tt old\_name new\_name}}
\cmdOpt{v}	{lists more information about the branches}
\cmdS{bundle}	{Move objects and refs by archive}
\cmdS{checkout}	{checkout a branch or paths to the working tree (prepend {\tt --} before path to avoid ambiguousity).}
\cmdOpt{b}	{create a branch {\tt new\_name} and switch to it instantly}
\cmdExmpl{\\checkout HEAD -- $dir$}	{restore working tree and reset index}
\cmdS{cherry-pick}	{can be used to change order of commits}
\cmdS{citool}	{Graphical alternative tocommit}
\cmdS{clean}	{Remove untracked files from the working tree}
\cmdOpt{f}	{force (required!)}
\cmdOpt{x}	{include hidden files}
\cmdOpt{d}	{directories as well}
\cmdS{clone}	{Clone a repository into a new directory}
\cmdS{commit}	{Record changes to the repository}
\cmdOpt{a}	{adding changes of files known by the Git repository to the commit}
\cmdOpt{m}	{Set comment for commitment -- correct it with prepending {\tt --amend} to argument}
\cmdS{describe}	{Show the most recent tag that is reachable from a commit}
\cmdS{diff}	{Show changes between commits, commit and working tree, etc.}
\cmdOptL{cached}	{compare stage area with last commit}
\cmdS{fetch}	{Download objects and refs from another repository}
\cmdS{format-patch}	{Prepare patches for e-mail submission}
\cmdS{gc}	{Cleanup unnecessary files and optimize the local repository}
\cmdS{grep}	{Print lines matching a pattern}
\cmdS{gui}	{A portable graphical interface to Git}
\cmdS{init}	{Create an empty git repository or reinitialize an existing one}
\cmdS{log}	{Show commit logs (prepend {\tt --} before path to avoid ambiguousity)}
\cmdOpt{p}	{show diffs of each commit}
\cmdOptL{stat}	{precise output with some stats}
\cmdOptLl{abbrev-commit}	{shortend (but unique) SHA-1 values for the commit objects }
\cmdOptL{oneline}	{show logs as shortened oneliner}
\cmdOptL{reverse}	{reverse log-history output}
\cmdOptL{follow}	{entire history including renames}
\cmdOptL{graph}	{show visual timeline}
\cmdExmpl{git log --pretty=format: --name-status | cut -f2- | sort -u}{show all
    files that ever existed in HEAD}  % http://superuser.com/a/429694
\cmdS{merge}	{Join two or more development histories together}
\cmdOpt{s}	{specify your merge strategy (see {\tt man git-merge})}
\cmdOpt{X}	{apply option to strategy (eg. $ours$, $theirs$)}
\cmdOptL{ff}	{only update the branch pointer, without creating a merge commit (default)}
\cmdS{mv}	{Move or rename a file, a directory, or a symlink}
\cmdS{notes}	{Add/inspect commit notes}
\cmdS{pull}	{Fetch from and merge with another re\-pository or a local branch}
\cmdS{push}	{Update remote refs along with associated objects}
\cmdExmpl{push origin :{\rm testbranch}}	{delete branch in remote repo called testbranch}
\cmdS{rebase}	{Forward-port local commits to the updated upstream head}
\cmdOpt{i}	{rebase interactively}
\cmdOptLl{autosquash}	{When the commit log message begins with "squash! ..." (or "fixup! ..."), automatically modify the todo list of {\tt rebase -i} }
\cmdS{reset}	{Reset current HEAD to the specified state (Remove a $file$ from staging area)}
\cmdOptL{soft}	{move HEAD pointer only}
\cmdOptL{mixed}	{resets staging area to HEAD (default!)}
\cmdOptL{hard}	{resets staging area and working tree to HEAD}
\cmdS{revert}	{creates a new commit that undoes the changes from a previous commit (adds new history to Project)}
\cmdS{rm}	{Remove files from the working tree and from the index}
\cmdOpt{r}	{remove recursive -- for removing additionally from repo, add
{\tt --cached *}}
\cmdS{shortlog}	{Summarize git log output}
\cmdS{show}	{Show various types of objects}
\cmdExmpl{\\show [reference]:[filename] > out.txt }	{allows you to see and retrieve files from bran\-ches, commits and tags}
\cmdS{stash}	{Stash the changes in a dirty working directory away}
\cmdS{status}	{Show the working tree status}
\cmdS{submodule}	{Initialize, update, add or inspect submodules}
\cmdOptLl{recurse-submodules}	{pull changes from main repo + submodules}
\cmdS{tag}	{Create, list, delete or verify a tag object signed with GPG}
\cmdS{gitk}	{The git repository browser}

\section{Manipulators}{}
\cmdS{config}	{Get and set repository or global options}
\cmdOptL{list}{show all items in config}
\cmdOptLl{get-regexp}{show given pattern in my configuration, e.g. {\tt 'alias'}}
\cmdOptL{global}{write to global {\tt \tild/.gitconfig} file}
\cmdOptL{system}{write to system-wide configuration}
\cmdOptL{local}{to repository's configuration {\tt .git/config}}
\cmdExmpl{config --global alias.staged 'diff --cached'}{set alias for staged file prompt}
\cmdS{fast-export}	{Git data exporter}
\cmdS{fast-import}	{Backend for fast Git data importers}
\cmdL{filter-branch}	{Rewrite branches}
\cmdS{mergetool}	{Run merge conflict resolution tools to resolve merge conflicts}
\cmdS{pack-refs}	{Pack heads and tags for efficient repository access}
\cmdS{prune}	{Prune all unreachable objects from the object database}
\cmdS{reflog}	{Manage reflog information}
\cmdS{relink}	{Hardlink common objects in local repositories}
\cmdS{remote}	{Manage set of tracked repositories}
\cmdOpt{v}	{show details about the remotes}
\cmdExmpl{remote update --prune}{remove all branches which are not in the remote anymore}
\cmdS{repack}	{Pack unpacked objects in a repository}
\cmdS{replace}	{Create, list, delete refs to replace objects}

\section{Interrogators}{}
\cmdS{annotate}	{Annotate file lines with commit information}
\cmdS{blame}	{\emergencystretch=5pt Show what revision and author last modified each line of a file}
\cmdS{cherry}	{Find commits not merged upstream}
\cmdL{count-objects}	{Count unpacked number of objects and their disk consumption}
\cmdS{difftool}	{Show changes using common diff tools}
\cmdS{fsck}	{Verifies the connectivity and validity of the objects in the database}
\cmdL{get-tar-commit-id}	{Extract commit ID from an archive created usingarchive}
\cmdS{help}	{Display help information about git}
\cmdS{instaweb}	{Instantly browse your working repository in gitweb}
\cmdS{merge-tree}	{Show three-way merge without touching index}
\cmdS{rerere}	{Reuse recorded resolution of conflicted merges}
\cmdS{rev-parse}	{Pick out and massage parameters}
\cmdS{show-branch}	{Show branches and their commits}
\cmdS{verify-tag}	{Check the GPG signature of tags}
\cmdS{whatchanged}	{Show logs with difference each commit introduces}

\section{Interacting with Others}{}
\cmdS{archimport}	{Import an Arch repository into git}
\cmdL{cvsexportcommit}	{Export a single commit to a CVS checkout}
\cmdS{cvsimport}	{Salvage your data out of another SCM people love to hate}
\cmdS{cvsserver}	{A CVS server emulator for git}
\cmdS{imap-send}	{Send a collection of patches from stdin to an IMAP folder}
\cmdS{quiltimport}	{Applies a quilt patchset onto the current branch}
\cmdS{request-pull}	{Generates a summary of pending chan\-ges}
\cmdS{send-email}	{Send a collection of patches as emails}
\cmdS{svn}	{Bidirectional operation between a Subversion repository and git}

\section{Manipulators (plumbing)}{}
\cmdS{apply}	{Apply a patch to files and/or to the index}
\cmdL{checkout-index}	{Copy files from the index to the working tree}
\cmdS{commit-tree}	{Create a new commit object}
\cmdS{hash-object}	{Compute object ID and optionally creates a blob from a file}
\cmdS{index-pack}	{Build pack index file for an existing packed archive}
\cmdS{merge-file}	{Run a three-way file merge}
\cmdS{merge-index}	{Run a merge for files needing merging}
\cmdS{mktag}	{Creates a tag object}
\cmdS{mktree}	{Build a tree-object from ls-tree formatted text}
\cmdS{pack-objects}	{Create a packed archive of objects}
\cmdS{prune-packed}	{Remove extra objects that are already in pack files}
\cmdS{read-tree}	{Reads tree information into the index}
\cmdS{symbolic-ref}	{Read and modify symbolic refs}
\cmdL{unpack-objects}	{Unpack objects from a packed archive}
\cmdS{update-index}	{Register file contents in the working tree to the index}
\cmdExmpl{git update-index --assume-unchanged <file>}	{push some version of file to remote repository and then disable changes tracking locally}
\cmdS{update-ref}	{Update the object name stored in a ref safely}
\cmdS{write-tree}	{Create a tree object from the current index}

\section{Interrogators (plumbing)}{}
\cmdS{cat-file}	{Provide content or type and size information for repository objects}
\cmdS{diff-files}	{Compares files in the working tree and the index}
\cmdS{diff-index}	{Compares content and mode of blobs between the index and repository}
% \cmdS{diff-tree}	{\emergencystretch=5pt Compares the content and mode of blobs found via two tree objects}
\cmdS{diff-tree}	{show files which have been changed by last commit}
\cmdOptLl{name-only}{show only names of files}
\cmdOpt{r}{recursively}
\cmdS{for-each-ref}	{Output information on each ref}
\cmdS{ls-files}	{Show information about files in the index and the working tree}
\cmdS{ls-remote}	{List references in a remote repository}
\cmdS{ls-tree}	{List the contents of a tree object}
\cmdExmpl{ls-tree -r master --name-only}{list all files for specific branch}
\cmdS{merge-base}	{Find as good common ancestors as possible for a merge}
\cmdS{name-rev}	{Find symbolic names for given revs}
\cmdL{pack-redundant}	{Find redundant pack files}
\cmdS{rev-list}	{Lists commit objects in reverse chronological order}
\cmdS{show-index}	{Show packed archive index}
\cmdS{show-ref}	{List references in a local repository}
\cmdS{unpack-file}	{Creates a temporary file with a blobâ€™s contents}
\cmdS{var}	{Show a git logical variable}
\cmdS{verify-pack}	{Validate packed git archive files}

\section{Synching repositories}{}
\cmdS{daemon}	{A really simple server for git repositories}
\cmdS{fetch-pack}	{Receive missing objects from another repository}
\cmdS{http-backend}	{Server side implementation of Git over HTTP}
\cmdS{send-pack}	{Push objects over git protocol to another repository}
\cmdL{update-server-info}	{Update auxiliary info file to help dumb servers}

\section{Helper commands}{}
\cmdS{http-fetch}	{Download from a remote git repository via HTTP}
\cmdS{http-push}	{Push objects over HTTP/DAV to another repository}
\cmdS{parse-remote}	{Routines to help parsing remote repository access parameters}
\cmdS{receive-pack}	{Receive what is pushed into the repository}
\cmdS{shell}	{Restricted login shell foronly SSH access}
\cmdL{upload-archive}	{Send archive back toarchive}
\cmdS{upload-pack}	{Send objects packed back tofetch-pack}

\section{Internal helper commands}{}
\cmdS{check-attr}	{Display gitattributes information}
\cmdL{check-ref-format}	{Ensures that a reference name is well formed}
\cmdL{fmt-merge-msg}	{Produce a merge commit message}
\cmdS{mailinfo}	{Extracts patch and authorship from a single e-mail message}
\cmdS{mailsplit}	{Simple UNIX mbox splitter program}
\cmdL{merge-one-file}	{The standard helper program to use withmerge-index}
\cmdS{patch-id}	{Compute unique ID for a patch}
\cmdS{sh-setup}	{Common git shell script setup code}
\cmdS{stripspace}	{Filter out empty lines}

%% Footer
\copyrightnotice

% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
