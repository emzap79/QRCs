%%%%%%%%%%%%%%
%  preamble  %
%%%%%%%%%%%%%%
% TeX Format

% version
\def\content{\uppercase{MatLab}}
\def\shortcontent{\content}
\def\versionnumber{0.4}  % Version of this reference card
\def\version{v\versionnumber\ \month\ \year}

% include stylefile
\input mydefs.sty
\mytitle

% shortcopyrightnotice
\shortintro
% \shortintroML

\section{Getting help}{All \ml functions have online documentation.}
\cmdS{help command}	{Help on command}
\cmdS{helpwin}	{invokes windowed help utility}
\cmdS{doc command}	{Detailed documentation on command (opens in help browser).}

\section{Commands and Functions}{}
\subsection{Workspace}{}
\cmdS{who}	{lists variables in memory}
\cmdS{whos}	{lists variable names, sizes, and types in memory}
\cmdS{format}	{invoke output style \ldots}
\cmdOper{sets}	{the default format how \ml displays numbers.}
\cmdOper{short}	{5 digit fixed point}
\cmdOper{long}	{15 digit fixed point}
\cmdL{clear, clear v}	{clears workspace, variable $v$}
\cmdL{close all, close n}	{closes all figure windows, window $n$}
\cmdS{Clc}	{clears command window}
\cmdS{Diary}	{creates a copy of all commands and most results}
\cmdS{clock, date}	{returns the time, date}
\cmdS{exit}	{terminates MATLAB}
\cmdS{quit}	{terminates MATLAB}
% ... Three or more periods at the end of a line continue the current command
% or function call onto the next line. Text on a line after ... is ignored.
% (Unlike C or Java, in \ml a command is normally terminated by a newline
% character.)

\subsection{File \& Folder Operations}{}
\cmdS{cd}	{change direction}
\cmdS{copyfile}	{copy from $pathA$ to $pathB$}
\cmdS{dir}	{output content of a folder}
\cmdS{exist}	{determines whether variable, function or folder exists}
\cmdL{open('workspace.mat'), load('workspace.mat')}	{opens file to command
    line, additionaly load it into worspace window}
\cmdS{csvwrite()}	{write to CSV format in current folder}


\section{Variable Information}{}
\cmdS{length(a)}	{the length of the vector $x$. For matrices length returns the number of rows or columns, whichever is larger.}
\cmdL{[x,y]=size(a)}	{the number of rows $(x)$ and columns $(y)$ of the matrix $a$}
\cmdS{size(a,1)}	{the number of rows of $a$}
\cmdS{size(a,2)}	{the number of columns of $a$}
\cmdS{numel(a)}	{the number of elements in $a$}
\cmdS{nnz(a)}	{the number of non-zero elements in $a$}

\subsection{Slicing and Extracting Data }{}
\subsubsection{Indexing vectors}{}
\cmdOper{x(1)}	{$1st$ element}
\cmdOper{x(n)}	{$nth$ element}
\cmdOper{x(end)}	{last element}
\cmdOper{x(1:n)}	{first $n$ elements}
\cmdOper{x(end-n:end)}	{last $n+1$ elements}
\cmdOper{x([1 2 4])}	{specific elements (use any row or column vector as index)}
\cmdOper{x(x>3)}	{all elements greater than $3$}
\cmdOper{x(x>3 \& x<5)}	{all elements between $3$ and $5$}
\cmdOper{x(:)}	{transformed to column vector}

\section{Data Selection and Manipulation}{}
\cmdS{x'}	{the complex conjugate transpose of $x$}
\cmdS{x.'}	{the non-conjugate transpose of $x$}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % % for matrices, the following commands work columnwise  % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\cmdS{max(x)}	{the greatest element of $x$}
\cmdS{min(x)}	{the smallest element of $x$}
\cmdS{fliplr(x)}	{reverses the elements of $x$ from left to right}
\cmdS{flipud(x)}	{reverses the elements of $x$ from top to bottom}
\cmdOper{[a,i]=max(x)}{returns in addition the position $i$ of the greatest element}
\cmdOper{[a,i]=min(x)}{returns in addition the position $i$ of the smallest element}
\cmdL{sort(x)}	{sorts the elements of $x$ in ascending order}
\cmdS{sortrows(x)}	{sorts the rows of $x$ in ascending order as a group, according to the first column.}
\cmdS{sortrows(x,c)}	{as above, but sorted according to column $c$. If $c$ is negative, the rows are sorted by descending order. If $c$ is a vector, the rows are sorted first by column $c(1)$, then by column $c(2)$, etc.}
\cmdS{find(x)}	{returns the indices corresponding to the nonzero entries of $x$}
\cmdS{find(x==a)}	{returns the indices of the positions $j$ such that $x[j]==a[j]$}
\cmdS{unique(x)}	{returns the same values as in a but with no repetitions; the values will also be sorted.}
\cmdL{reshape(x,m,n)}	{returns the $m  \times  n matrix$ whose elements are taken columnwise from $x$.}

\section{Math}{}
\subsection{Basic Math Functions}{These are the standard mathematical functions; they always
    operate pointwise on their arguments.}
\cmdS{sum(x)}	{sum of the elements of $x$}
\cmdS{prod(x)}	{product of the elements of $x$}
\cmdS{diff(x)}	{difference (and sample-wise derivative) of the vector $x$}
\cmdS{cumsum(x)}	{cumulative sum of the elements of $x$ (and sample-wise integral)}
\cmdS{cumprod(x)}	{same, for the product}
\cmdS{mean(x)}	{mean of the elements of $x$}
\cmdS{median(x)}	{median of the elements of $x$}
\cmdS{log(x, base)}	{computes the logarithm of $x$ with base $base$}
\cmdS{real(x)}	{real part of a complex number}
\cmdS{imag(x)}	{imaginary part of a complex number}
\cmdS{abs(x)}	{absolute value of $x$, or complex magnitude if $x$ is a complex number}
\cmdS{angle(x)}	{angle in radians of the complex number}
\cmdS{conj(x)}	{the complex conjugate of $x$}
\cmdExmpl{sin, cos, tan, asin, acos, atan, atan2, log, log10, exp, \ldots}	{other functions}

\subsection{Basic Math Operations}{}
\cmdOper{+}	{addition}
\cmdOper{-}	{subtraction}
\cmdOper{*}	{multiplication}
\cmdOper{.*}	{array multiplication}
\cmdOper{/}	{division}
\cmdOper{./}	{array division}
\cmdOper{\expon}	{exponential}
\cmdOper{.\expon}	{array exponential}

\subsection{Special Characters}{}
\cmdOper{[]}	{forms matrices}
\cmdOper{()}	{used in statements to group operations}
\cmdOper{.}	{decimal point}
\cmdOper{,! }	{separates subscripts or matrix elements}
\cmdOper{;}	{separates rows in a matrix definition or suppresses output}
\cmdOper{:}	{indicates all rows or all columns}
\cmdOper{=}	{assignment operator (not equality)}
\cmdOper{\%}	{indicates a comment}
\cmdOper{\%\%}	{cell divider}

\subsection{Special Variables \& Constants}{}
% \cmdOper{i,j}	{\begin{math}\sqrt[]{-1}\end{math}}
\cmdOper{Inf}	{Infinity; results e.g. when dividing a non-zero value by zero.}
\cmdOper{NaN}	{Not a number; results e.g. when computing $0/0$.}
\cmdOper{ans}	{most recent temporary answer}
\cmdOper{eps}	{Spacing of floating point numbers. Use it to prevent unwanted behavior due to rounding errors.}
\cmdExmpl{$2.2204e^{-16}$}	{default}
\cmdOper{exp(1)}	{The base of the natural logarithm.}
\cmdOper{flops}	{count of floating point operations}
\cmdOper{i}	{Imaginary unit $sqrt(1)$}
\cmdOper{j}	{same.}
\cmdOper{pi}	{the math pi (3.1415e)}
\cmdOper{realmin, realmax}	{smallest, largest real number MATLAB can represent}
\cmdOper{intmin, intmax}	{returns smallest, largest possible integer used in MATLAB}
% Attention: It is possible to assign a value to a predefined constant and
% thus to override its original value (MATLAB will not warn you if you do so.)

\subsection{Relational and Logical Operators}{}
\cmdOper{<}	{less than}
\cmdOper{<==}	{less than or equal to}
\cmdOper{>}	{greater than}
\cmdOper{>==}	{greater than or equal to}
\cmdOper{==}	{equal to}
\cmdOper{\tild=}	{not equal to}
\cmdOper{\&}	{and}
\cmdOper{!}	{or}
\cmdOper{\tild}	{not}

\section{Vectors \& Matrices}{}
\subsection{Creating Vectors}{}
\cmdOper{linspace(a,b,n)}	{a row vector with $n$ values linearly spaced from $a$ to $b$ (inclusive)}
\cmdOper{x=[1,2,4,\ldots]}	{define a row vector $x$}
\cmdOper{x=[1 2 4 \ldots]}	{same.}
\cmdOper{x=[1; 2; 5; \ldots]}	{define a column vector $x$}
\cmdOper{a:c}	{the range $a..c$; equivalent to $[a,a+1,...,c-1,c]$}
\cmdOper{a:b:c}	{the range $a..c$ with step size $b$; equivalent to $[a,a+b,a+2*b,..., c-b,c]$ }

\subsection{Creating Matrices}{}
\cmdS{eye(n)}	{the $n \times n$ identity matrix}
\cmdS{zeros(n)}	{a $n \times n$ zero matrix}
\cmdS{zeros(m,n)}	{a $m \times n$ zero matrix}
\cmdS{ones(n)}	{a $n \times n$ all-one matrix}
\cmdS{ones(m,n)}	{a $m \times n$ all-one matrix}
\cmdS{diag(x)}	{creates a diagonal matrix whose diagonal consists of the entries of the vector $x$}
\cmdL{[X,Y]=meshgrid(x,y)}	{transforms the domain specified by vectors $x$ and $y$ into matrices
    $X$ and $Y$ that can be used for the evaluation of functions of two variables.}

\subsubsection{Indexing matrices}{}
\cmdOper{x(i,j)}	{element at row $i$, column $j$}
\cmdOper{x(i,:)}	{row $i$}
\cmdOper{x(:,j)}	{column $j$}
\cmdOper{x(1:m,:)}	{first $n$ rows}
\cmdOper{x(:,1:n)}	{first $n$ columns}
\cmdOper{x(end,end)}	{The last element in the last row}
\cmdOper{x(:)}	{transformed to column vector (column by column)}

\subsection{Matrix Computations}{}
\cmdOper{a+b}	{If $a$ and $b$ are $m \times n$ matrices, this is the standard matrix addition. If $a$ is a matrix and $b$ is a scalar, or vice-versa, the scalar is added to every entry of the matrix.}
\cmdOper{a-b}	{If $a$ and $b$ are $m \times n$ matrices, this is the standard matrix subtraction. If $a$ is a matrix and $b$ is a scalar, or vice-versa, the scalar is subtracted from every entry of the matrix.}
\cmdOper{a*b}	{If $a$ is an $k \times m$ matrix and $b$ is an $m \times n$ matrix, this is the standard matrix multiplication, i.e., yielding an $k \times m$ matrix. If $a$ is a matrix and $b$ is a scalar, or vice-versa, every element of the matrix is multiplied by the scalar.}
\cmdOper{a.*b}	{If $a$ and $b$ are $m \times n$ matrices, this is their pointwise multiplication. If either element is a scalar, this is the same as $a*b$.}
\cmdOper{a/b}	{If $a$ and $b$ are matrices of appropriate dimensions, this is roughly $a*inv(b).$ If $b$ is a scalar, this divides every entry of $a$ by $b$.}
\cmdOper{a./b}	{If $a$ and $b$ are $m \times n$ matrices, this is their
pointwise division. If $a$ is a scalar, then this divides a by every entry of
$b$. If $b$ is a scalar, then this divides every entry of $a$ by $b$. }
\cmdOper{a\bs b}	{If $a$ is an $n \times n$ matrix and $b$ is an $n \times
1$ column vector, or a matrix with several such columns, then $x=a$\bs$b$ is the
solution to the equation $a*x=b$. If a is a scalar, then this divides every
entry of $b$ by $a$.}
\cmdOper{$a.$\bs$b$}	{If $a$ and $b$ are $m \times n$ matrices, this is their
left pointwise division. If a is a scalar, then this divides every entry of $b$
by $a$. If $b$ is a scalar, then this divides $b$ by every entry of $a$.}
\cmdOper{$a'*b$}	{If $a$ and $b$ are $n \times 1$ column vectors, this is their inner product (or scalar product or dot product). (This is not another operator, just a combination of ' (conjugate transpose) and *).}
\cmdOper{inv(a)}	{The inverse of the $n \times n$ matrix $a$.}
\cmdOper{eig(a)}	{is a vector containing the eigenvalues of the $n \times n$ matrix $a$.}
\cmdOper{[v,d]=eig(a)}	{produces a diagonal matrix d of eigenvalues and a full
    matrix $v$ whose columns are the corresponding eigenvectors such that $a*v=v*d$.}
\cmdOper{rank(a)}	{is the rank, or number of linearly independent rows or columns of the matrix $a$.}

\subsection{Sparse Matrices}{Using sparse matrices can result in a significant
    computational gain if you work with large matrices that have relatively few
        non-zero entries.}
\cmdS{sparse(x)}	{converts a sparse or full matrix to sparse}
\cmdS{sparse(m,n)}	{creates an $m \times n$ all-zero sparse matrix}
\cmdS{speye(n)}	{creates an $n \times n$ sparse identity matrix}
\cmdS{spones(x)}	{creates a matrix with the same sparsity structure as $x$, but with ones in the nonzero positions.}

\section{Signal Processing}{}
\cmdS{c=conv(a,b)}	{Convolution; e.g., $c(1)=a(1)*b(1)$}
\cmdS{c=xcorr(a,b)}	{Cross-correlation estimates.}
\cmdS{fft(x)}	{Fast Fourier Transform of the vector $x$}
\cmdS{ifft(x)}	{Inverse Fast Fourier Transform}
\cmdS{fftshift(x)}	{swaps the left and right halves of $x$ to shift the zerofrequency component to the center of the spectrum.}
\cmdL{filter(b,a,x)}	{filters the data in vector $x$ with the filter described by vectors $a$ and $b$.}
\cmdOper{[b,a]=butter(n,Wn)}	{designs an nth order lowpass digital
    Butterworth filter and returns the filter coefficients in the vectors b
        (numerator) and a (denominator). The cutoff frequency must be $0.0 < Wn < 1.0$,
        with $1.0$ corresponding to half the sample rate.}
\cmdL{downsample(x,n)}	{downsamples the signal $x$ by keeping every nth sample starting with the first.}
\cmdL{upsample(x,n)}	{upsamples the signal $x$ by inserting $n?1$ zeros between input samples.}
\cmdL{resample(x,p,q)}	{resamples the signal $x$ at $p/q$ times the original sample rate.}

\section{Communication Toolbox}{}
\cmdS{randint(m,n)}	{generates an $m \times n$ matrix of random binary numbers.}
\cmdL{randint(m,n,p)}	{generates an $m \times n$ matrix of random integers between $0$ and $p-1$.}
\cmdL{pskmod,pskdemod}	{phase shift keying modulation, demodulation}
\cmdL{qammod,qamdemod}	{quadrature amplitude modulation, demodulation}
\cmdS{rcosine}	{designs a raised or root raised cosine filter}
\cmdS{rcosflt}	{filters a signal using raised or root raised cosine filter}
\cmdS{awgn}	{add white Gaussian noise to a signal}
\cmdS{biterr}	{computes the bit error rate}
\cmdS{symerr}	{computes the symbol error rate}

\section{Plotting}{}
\cmdS{plot(x)}	{plot of the values of $x$ (on the y-axis) versus $0:length(x)-1$}
\cmdS{plot(x,y)}	{bivariate plot of $x$ (on the x-axis) and y (on the y-axis)}
\cmdS{plot(x,y,\ldots)}	{allows you to specify formatting options (cf. help plot)}
\cmdS{hist(x)}	{histogram of the frequencies of $x$}
\cmdS{stem(\ldots)}	{is the same as $plot(\ldots)$, but the data sequence is plotted as discrete "stems" from the x-axis with circles for the data values.}
\cmdS{semilogy(\ldots)}	{is the same as $plot(\ldots)$, except a logarithmic (base 10) scale is used for the y-axis.}
\cmdL{scatterplot(x)}	{generates a scatter plot of $x$. $x$ can be a real or complex vector, or a two-column matrix with real signal in the first column and imaginary signal in the second column.}

\section{Figures}{}
% % Plots are drawn on figure windows. The following commands control the
% % appearance of figures and plots.
\cmdS{h=figure}	{creates a new figure and returns its handle.}
\cmdS{figure(h)}	{makes h the current figure, forces it to become visible, and raises it above all other figures on the screen.}
\cmdL{figure('name', '\ldots')}	{creates a new figure window with the specified window title}
\cmdL{subplot(m,n,k)}	{divides the current figure window into $m \times n$ subfigures and selects the $kth$ for the current plot.}
\cmdS{xlabel('\ldots')}	{sets the text for the x-axis. $xlabel$, as well as
$ylabel$, title etc. accept basic \ltx-like strings such as $a$\expon $2$ for
$a^2$ or \bs $alpha$ for $\alpha$.}
\cmdS{ylabel('\ldots')}	{sets the text for the y-axis.}
\cmdS{title('\ldots')}	{sets a title for the current plot.}
\cmdL{print -depsc2 fig.eps}	{saves the current figure into the file $fig.eps$.}

\section{Input and Output}{}
\cmdL{input('prompt', fmt)}	{shows prompt for user input}
\cmdExmpl{x=input('foo bar: ')}	{assigns 'string' to variable $x$ (quotation marks matters)}
\cmdExmpl{x=input('foo bar: ', s)}	{option 's' interprets all input as character string, eg. numbers.}
\cmdS{disp(x)}	{displays the contents of variable $x$}
\cmdL{fprintf(fmt, vars, \ldots)}	{Like the C function $printf$}
% % formatstrings
%     %d  integer
%     %f  real number in decimal notation
%     %e  real number in exponential notation
%     %g  real number, optimized notation
%     %s  textstring
%     %c  single character
% % exmpl: fprintf('x=%7.5f \n', pi);
% % >> x=3.14159

\cmdL{isnumeric(), ischar()}	{tests whether content of $x$ is numeric or a character textstring (boolean logic).}
\cmdL{sprintf(fmt, vars, \ldots)}	{Like $printf$, but returns the string instead of printing it to the screen.}
\cmdS{error('\ldots')}	{displays an error message and halts execution. The message
can also be a formatting string as for $fprintf$, followed by the corresponding
variables, e.g. error('Warning \bs \%d\bs n', val).}

\cmdS{warning('\ldots')}	{Like error, but execution of the function/script is continued. }
\cmdS{waitbar}	{displays progress information.}
\cmdS{load foo}	{loads the variables saved in the file $foo.mat$ into the current workspace.}
\cmdS{load('foo')}	{returns the variables saved in the file $foo.mat$ as a structure;}
\cmdExmpl{if $foo.mat$ contains variables $x$ and $y$, and you load the file like this,
    then $x$ and $y$ will be accessible as $a.x$ and $a.y$.}	{a = load('foo')}
\cmdL{save foo a b \or\ save('foo', 'a', 'b')}	{saves the variables $a, b$, etc. in the file $foo.mat$.}

\section{String Conversions}{}
% % String to Function/Number
\cmdOper{func2str}	{Constructs a function name string from a function handle}
\cmdOper{str2func}	{Constructs a function handle from a function name string}
\cmdOper{int2str}	{Integer to string conversion}
\cmdOper{mat2str}	{Convert a matrix into a string}
\cmdOper{num2str}	{Number to string conversion}
\cmdOper{sprintf}	{Write formatted data to a string}
\cmdOper{sscanf}	{Read string under format control}
\cmdOper{str2double}	{Convert string to double-precision value}
\cmdOper{str2mat}	{String to matrix conversion}
\cmdOper{str2num}	{String to number conversion}
% % Radix Conversion
\cmdOper{bi\grey{n}2de\grey{c}}	{Binary to decimal number conversion}
\cmdOper{de\grey{c}2bi\grey{n}}	{Nonnegative integer decimal to binary number conversion}
\cmdOper{dec2hex}	{Decimal to hexadecimal number conversion}
\cmdOper{hex2dec}	{Hexadecimal to decimal number conversion}
\cmdOper{hex2num}	{Hexadecimal to double number conversion}

\section{Conditional Statements}{}
\vtop{\tt
    {if expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {elsif expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {else expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}

\vtop{\tt
    {switch switch\_expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {case case\_expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {case case\_expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {otherwise}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}

\vtop{\tt
    {for k = vectorOrColumnList}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}

\vtop{\tt
    {while logicalExpression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}
% \section{MATLAB vs R}{}
% http://home.online.no/~pjacklam/r/doc/matlab_vs_r.html

% Matlab vs R function and operator names
% 
% Matlab	 	R
% size          dim
% [...]         c, rbind, cbind
% permute		aperm
% error         stop
% ceil          ceiling
% linspace		seq
% :             : (but behaves differently)
% ones(...)		rep(1, ...), matrix(1, ...), array(1, ...)
% zeros(...)	rep(0, ...), matrix(0, ...), array(0, ...)
% ~             !
% ~=            !=
% logical		as.logical
% cd            getwd, setwd
% cell          list, as.list
% sprintf		formatC
% eval('...')		eval(parse(text = "..."))
% reshape(x, s)		array(x, s), dim(x) <- s

% Footer
\copyrightnotice

% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
