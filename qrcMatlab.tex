%%%%%%%%%%%%%%
%  preamble  %
%%%%%%%%%%%%%%
% TeX Format

% version
\def\content{\uppercase{MatLab}}
\def\shortcontent{\content}
\def\versionnumber{1.0}  % Version of this reference card
\def\version{v\versionnumber\ \month\ \year}

% include stylefile
\input mydefs.sty
\mytitle

% shortcopyrightnotice
\shortintro
\shortintroML

\section{Getting help}{All \ml functions have online documentation.}
\cmdS{help command}	{Help on command}
\cmdS{helpwin}	{invokes windowed help utility}
\cmdS{doc command}	{Detailed documentation on command (opens in help browser).}

\section{Commands and Functions}{Three or more periods at the end of a
line continue the current command or function call onto the next line. Text on
a line after \lldots\ is ignored. (Unlike C or Java, in \ml a command is normally
terminated by a newline character.)}

\subsection{Workspace}{}
\cmdS{who}	{lists variables in memory}
\cmdS{whos}	{lists variable names, sizes, and types in memory}
\cmdL{format $short$, $long$, $sets$}	{invoke 5, 15, default digit fixed point output style}
\cmdM{clear, clear $a$}	{clears workspace, variable $a$}
\cmdS{close $all$, $n$}	{closes $all$ figure windows, window $n$}
\cmdS{Clc}	{clears command window}
\cmdS{Diary}	{creates a copy of all commands and most results}
\cmdS{clock, date}	{returns the time, date}
\cmdS{exit, quit}	{terminates MATLAB}

\subsection{File \& Folder Operations}{}
\cmdS{cd}	{change direction}
\cmdS{copyfile}	{copy from $pathA$ to $pathB$}
\cmdS{dir}	{output content of a folder}
\cmdS{exist}	{determines whether variable, function or folder exists}

\section{Input and Output}{}
\subsection{Prompt \& Return Data}{}
\cmdS{disp($a$)}	{displays the contents of variable $a$}
\cmdL{input('prompt', fmt)}	{shows prompt for user input}
\cmdExmpl{a=input('foo: ', s)}	{interprets input as characterstring and assigns it to $a$}
\cmdL{fprintf(fmt, vars, \ldots)}	{formats data and displays the results on
    the screen (Like the C function $printf$).}
\cmdExmpl{>> a=3.14159}{fprintf('a=\%7.5f \bs n', pi); gives you back}\\
\cmdL{sprintf(fmt, vars, \ldots)}	{Like $fprintf$, but returns the string instead of printing it to the screen.}

\subsubsection{Formatstrings}{}
\cmdOper{\%d}	{integer}
\cmdOper{\%f}{real number in decimal notation}
\cmdOper{\%e}{real number in exponential notation}
\cmdOper{\%g}{real number, optimized notation}
\cmdOper{\%s}{textstring}
\cmdOper{\%c}{single character}

\subsection{File Processing}{}
\cmdS{waitbar}	{displays progress information.}
\cmdL{error('\ldots'), warning('\ldots')}	{displays an error message and halts, continues execution.}
\cmdExmpl{error('Warning \bs \%d\bs n', val)}{The message can also be a formatting string, followed by the corresponding variables}
\cmdS{save $foo$ $a$ $b$}	{saves the variables $a, b$, etc. in the file $foo.mat$.}
\cmdS{edit($foo$)}	{opens the specified or nonexistent empty $file$ in the Editor.}
\cmdL{open($foo.mat$), load($foo.mat$)}	{opens file $foo.mat$ to command
    line, additionaly load it into worspace window}
\cmdExmpl{a = load('foo')}	{if $foo.mat$ contains variables $x$ and $y$, then $x$ and $y$ will be
    accessible as $a.x$ and $a.y$}

\section{Slicing and Extracting Data }{ATTENTION: It is possible to assign
a value to a predefined constant and thus to override its original value
(\ml will not warn you if you do so).}
\cmdS{size($x$,1)}	{the number of rows of $x$.}
\cmdS{size($x$,2)}	{the number of columns of $x$.}
\cmdExmpl{[$a$,$b$]=size($x$)}	{the number of rows $a$ and columns $b$ of the
    matrix $x$}
\cmdL{numel($x$), nnz($x$)}	{the number of elements, non-zero elements in $x$.}
\cmdS{length($x$)}	{the length of the vector $x$. For matrices length returns
    the number of rows or columns, whichever is larger.}
\cmdL{isnumeric($x$), ischar($x$)}	{tests whether content of $x$ is numeric or
    a character textstring (boolean logic).}

\subsection{Creating Vectors}{}
\cmdOper{linspace(a,b,n)}	{a row vector with $n$ values linearly spaced from $a$ to $b$ (inclusive)}
\cmdOper{x=[1,2,4,\lldots]}	{define a row vector $x$ (commata replacable through spacecharacter).}
\cmdOper{x=[1; 2; 5; \ldots]}	{define a column vector $x$}
\cmdOper{a:c}	{the range $a..c$; equivalent to $[a,a+1,...,c-1,c]$}
\cmdOper{a:b:c}	{the range $a..c$ with step size $b$; equivalent to $[a,a+b,a+2*b,..., c-b,c]$ }

\subsection{Indexing vectors}{}
\cmdOper{x(1)}	{$1st$ element}
\cmdOper{x(n)}	{$nth$ element}
\cmdOper{x(end)}	{last element}
\cmdOper{x(1:n)}	{first $n$ elements}
\cmdOper{x(end-n:end)}	{last $n+1$ elements}
\cmdOper{x([1 2 4])}	{specific elements (use any row or column vector as index)}
\cmdOper{x(x>3)}	{all elements greater than $3$}
\cmdOper{x(x>3 \& x<5)}	{all elements between $3$ and $5$}
\cmdOper{x(:)}	{transformed to column vector}

\subsection{Special Characters}{}
\cmdOper{[]}	{forms matrices}
\cmdOper{()}	{used in statements to group operations}
\cmdOper{.}	{decimal point}
\cmdOper{,! }	{separates subscripts or matrix elements}
\cmdOper{;}	{separates rows in a matrix definition or suppresses output}
\cmdOper{:}	{indicates all rows or all columns}
\cmdOper{=}	{assignment operator (not equality)}
\cmdOper{\%}	{indicates a comment}
\cmdOper{\%\%}	{cell divider}

\section{Data Selection and Manipulation}{for matrices, the following commands work columnwise.}
\cmdM{min(x), max(x)}	{the smallest, greatest element of $x$.}
\cmdExmpl{[a,i]=max(x)}{returns in addition the position $i$ of the greatest element.}
\cmdL{fliplr(x), flipud(x)}	{reverses the elements of $x$ from left to right, top to bottom.}
\cmdL{sort(x), sortrows(x)}	{sorts the elements of $x$ in ascending order, as a group and according to the first column.}
\cmdM{sortrows(x,c)}	{as above, but sorted according to column $c$. If $c$
    is negative, the rows are sorted by descending order. If $c$ is a vector, the
    rows are sorted first by column $c(1)$, then by column $c(2)$, etc.}
\cmdS{find(x)}	{returns the indices corresponding to the nonzero entries of $x$.}
\cmdExmpl{find(x==a)}	{returns the indices of the positions $j$ such that $x[j]==a[j]$}
\cmdS{unique(x)}	{returns the same values as in a but with no repetitions; the values will also be sorted.}
\cmdM{reshape(x,m,n)}	{returns the $m  \times  n$ matrix whose elements are taken columnwise from $x$.}

\section{Math}{}
\subsection{Basic Math Functions}{These are the standard mathematical functions; they always
    operate pointwise on their arguments.}
\cmdM{sum(x), prod(x)}	{sum, product of the elements of $x$}
\cmdS{diff(x)}	{difference (and sample-wise derivative) of the vector $x$}
\cmdS{cumsum(x)}	{cumulative sum of the elements of $x$ (and sample-wise integral)}
\cmdS{cumprod(x)}	{same, for the product}
\cmdL{mean(x), median(x)}	{mean, median of the elements of $x$}
\cmdM{log(x, base)}	{computes the logarithm of $x$ with base $base$}
\cmdL{real(x), imag(x)}	{real, imaginary part of a complex number}
\cmdS{abs(x)}	{absolute value of $x$ (or complex magnitude if $x$ is a complex number)}
\cmdS{angle(x)}	{angle in radians of the complex number}
\cmdS{conj(x)}	{the complex conjugate of $x$}
\cmdExmpl{sin, cos, tan, asin, acos, atan, atan2, log, log10, exp, \ldots}	{other functions}

\subsection{Basic Math Operations}{}
\cmdOper{+}	{addition}
\cmdOper{-}	{subtraction}
\cmdOper{*}	{multiplication}
\cmdOper{.*}	{array multiplication}
\cmdOper{/}	{division}
\cmdOper{./}	{array division}
\cmdOper{\expon}	{exponential}
\cmdOper{.\expon}	{array exponential}

\subsection{Special Variables \& Constants}{}
\cmdOper{i,j}	{Imaginary unit squirt: $\sqrt[{-1}]$}
\cmdOper{Inf}	{Infinity; results e.g. when dividing a non-zero value by zero.}
\cmdOper{NaN}	{Not a number; results e.g. when computing $0/0$.}
\cmdOper{ans}	{most recent temporary answer}
\cmdOper{eps}	{Spacing of floating point numbers. Use it to prevent unwanted behavior due to rounding errors.}
\cmdExmpl{$2.2204e^{-16}$}	{default}
\cmdOper{exp(1)}	{The base of the natural logarithm.}
\cmdOper{flops}	{count of floating point operations}
\cmdOper{pi}	{the math pi (3.1415e)}
\cmdOper{realmin, realmax}	{smallest, largest real number MATLAB can represent}
\cmdOper{intmin, intmax}	{returns smallest, largest possible integer used in MATLAB}

\subsection{Relational and Logical Operators}{}
\cmdOper{<}	{less than}
\cmdOper{<==}	{less than or equal to}
\cmdOper{>}	{greater than}
\cmdOper{>==}	{greater than or equal to}
\cmdOper{==}	{equal to}
\cmdOper{\tild=}	{not equal to}
\cmdOper{\&}	{and}
\cmdOper{!}	{or}
\cmdOper{\tild}	{not}

\section{Matrices}{}

\subsection{Creating Matrices}{}
\cmdS{eye(n)}	{the $n \times n$ identity matrix}
\cmdS{zeros(n)}	{a $n \times n$ zero matrix}
\cmdS{zeros(m,n)}	{a $m \times n$ zero matrix}
\cmdS{ones(n)}	{a $n \times n$ all-one matrix}
\cmdS{ones(m,n)}	{a $m \times n$ all-one matrix}
\cmdS{diag(x)}	{creates a diagonal matrix whose diagonal consists of the entries of vector $x$}
\cmdExmpl{[X,Y]=meshgrid(x,y)}	{transforms the domain specified by vectors $x$ and $y$ into matrices
    $X$ and $Y$ that can be used for the evaluation of functions of two variables}

\subsection{Matrix Computations}{}
\cmdOper{a+b}	{If $a$ and $b$ are $m \times n$ matrices, this is the standard matrix addition. If $a$ is a matrix and $b$ is a scalar, or vice-versa, the scalar is added to every entry of the matrix.}
\cmdOper{a-b}	{If $a$ and $b$ are $m \times n$ matrices, this is the standard matrix subtraction. If $a$ is a matrix and $b$ is a scalar, or vice-versa, the scalar is subtracted from every entry of the matrix.}
\cmdOper{a*b}	{If $a$ is an $k \times m$ matrix and $b$ is an $m \times n$ matrix, this is the standard matrix multiplication, i.e., yielding an $k \times m$ matrix. If $a$ is a matrix and $b$ is a scalar, or vice-versa, every element of the matrix is multiplied by the scalar.}
\cmdOper{a.*b}	{If $a$ and $b$ are $m \times n$ matrices, this is their pointwise multiplication. If either element is a scalar, this is the same as $a*b$.}
\cmdOper{a/b}	{If $a$ and $b$ are matrices of appropriate dimensions, this is roughly $a*inv(b).$ If $b$ is a scalar, this divides every entry of $a$ by $b$.}
\cmdOper{a./b}	{If $a$ and $b$ are $m \times n$ matrices, this is their
pointwise division. If $a$ is a scalar, then this divides a by every entry of
$b$. If $b$ is a scalar, then this divides every entry of $a$ by $b$. }
\cmdOper{a\bs b}	{If $a$ is an $n \times n$ matrix and $b$ is an $n \times
1$ column vector, or a matrix with several such columns, then $x=a$\bs$b$ is the
solution to the equation $a*x=b$. If a is a scalar, then this divides every
entry of $b$ by $a$.}
\cmdOper{$a.$\bs$b$}	{If $a$ and $b$ are $m \times n$ matrices, this is their
left pointwise division. If a is a scalar, then this divides every entry of $b$
by $a$. If $b$ is a scalar, then this divides $b$ by every entry of $a$.}
\cmdOper{$a'*b$}	{If $a$ and $b$ are $n \times 1$ column vectors, this is
    their inner product (or scalar product or dot product). (This is not another
    operator, just a combination of ' (conjugate transpose) and *).}
\cmdOper{inv(a)}	{The inverse of the $n \times n$ matrix $a$.}
\cmdOper{eig(a)}	{is a vector containing the eigenvalues of the $n \times n$ matrix $a$.}
\cmdExmpl{[v,d]=eig(a)}	{produces a diagonal matrix d of eigenvalues and a full
    matrix $v$ whose columns are the corresponding eigenvectors such that $a*v=v*d$}
\cmdOper{rank(a)}	{is the rank, or number of linearly independent rows or columns of the matrix $a$.}

\subsection{Indexing matrices}{}
\cmdOper{x'}	{the complex conjugate transpose of $x$}
\cmdOper{x.'}	{the non-conjugate transpose of $x$}
\cmdOper{x(i,j)}	{element at row $i$, column $j$}
\cmdOper{x(i,:)}	{row $i$}
\cmdOper{x(:,j)}	{column $j$}
\cmdOper{x(1:m,:)}	{first $n$ rows}
\cmdOper{x(:,1:n)}	{first $n$ columns}
\cmdOper{x(end,end)}	{The last element in the last row}
\cmdOper{x(:)}	{transformed to column vector (column by column)}

\subsection{Sparse Matrices}{Using sparse matrices can result in a significant
    computational gain if you work with large matrices that have relatively few
    non-zero entries.}
\cmdS{sparse(x)}	{converts a sparse or full matrix to sparse}
\cmdS{sparse(m,n)}	{creates an $m \times n$ all-zero sparse matrix}
\cmdS{speye(n)}	{creates an $n \times n$ sparse identity matrix}
\cmdS{spones(x)}	{creates a matrix with the same sparsity structure as $x$, but with ones in the nonzero positions.}

\section{Signal Processing}{}
\cmdS{c=conv(a,b)}	{Convolution; e.g., $c(1)=a(1)*b(1)$}
\cmdS{c=xcorr(a,b)}	{Cross-correlation estimates.}
\cmdS{fft(x)}	{Fast Fourier Transform of the vector $x$}
\cmdS{ifft(x)}	{Inverse Fast Fourier Transform}
\cmdS{fftshift(x)}	{swaps the left and right halves of $x$ to shift the zerofrequency component to the center of the spectrum.}
\cmdM{filter(b,a,x)}	{filters the data in vector $x$ with the filter described by vectors $a$ and $b$.}
\cmdS{butter(n,Wn)}	{designs an nth order lowpass digital Butterworth filter.}
\cmdExmpl{[b,a]=butter(n,Wn)}	{returns the filter coefficients in the vectors $b$
    (numerator) and $a$ (denominator). The cutoff frequency must be $0.0 < Wn < 1.0$,
    with $1.0$ corresponding to half the sample rate}
\cmdM{downsample(x,n)}	{downsamples the signal $x$ by keeping every nth sample starting with the first.}
\cmdM{upsample(x,n)}	{upsamples the signal $x$ by inserting $n$ zeros between input samples.}
\cmdM{resample(x,p,q)}	{resamples the signal $x$ at $p/q$ times the original sample rate.}

\section{Communication Toolbox}{}
\cmdS{randint(m,n)}	{generates an $m \times n$ matrix of random binary numbers.}
\cmdM{randint(m,n,p)}	{generates an $m \times n$ matrix of random integers between $0$ and $p-1$.}
\cmdL{pskmod, pskdemod}	{phase shift keying modulation, demodulation}
\cmdL{qammod, qamdemod}	{quadrature amplitude modulation, demodulation}
\cmdS{rcosine}	{designs a raised or root raised cosine filter}
\cmdS{rcosflt}	{filters a signal using raised or root raised cosine filter}
\cmdS{awgn}	{add white Gaussian noise to a signal}
\cmdS{biterr}	{computes the bit error rate}
\cmdS{symerr}	{computes the symbol error rate}

\section{Charts \& Figures}{}
\subsection{Plotting}{}
\cmdS{plot(x)}	{plot of the values of $x$ (on the y-axis) versus $0:length(x)-1$}
\cmdS{plot(x,y)}	{bivariate plot of $x$ (on the x-axis) and y (on the y-axis)}
\cmdS{plot(x,y,\ldots)}	{allows you to specify formatting options (cf. help plot)}
\cmdS{hist(x)}	{histogram of the frequencies of $x$}
\cmdS{stem(\ldots)}	{is the same as $plot(\ldots)$, but the data sequence is plotted as discrete "stems" from the x-axis with circles for the data values.}
\cmdS{semilogy(\ldots)}	{is the same as $plot(\ldots)$, except a logarithmic (base 10) scale is used for the y-axis.}
\cmdM{scatterplot(x)}	{generates a scatter plot of $x$. $x$ can be a real or complex vector, or a two-column matrix with real signal in the first column and imaginary signal in the second column.}

\subsection{Figures}{Plots are drawn on figure windows. The following commands
    control the appearance of figures and plots.}
\cmdS{h=figure}	{creates a new figure and returns its handle.}
\cmdS{figure(h)}	{makes h the current figure, forces it to become visible, and raises it above all other figures on the screen.}
\cmdL{figure('name', '\ldots')}	{creates a new figure window with the specified window title}
\cmdL{subplot(m,n,k)}	{divides the current figure window into $m \times n$ subfigures and selects the $kth$ for the current plot.}
\cmdS{xlabel('\ldots')}	{sets the text for the x-axis. $xlabel$, as well as
$ylabel$, title etc. accept basic \ltx-like strings such as $a$\expon $2$ for
$a^2$ or \bs $alpha$ for $\alpha$.}
\cmdS{ylabel('\ldots')}	{sets the text for the y-axis.}
\cmdS{title('\ldots')}	{sets a title for the current plot.}

\section{String Conversions}{}
\subsection{String to Function/Number}{}
\cmdOper{func2str}	{Constructs a function name string from a function handle}
\cmdOper{str2func}	{Constructs a function handle from a function name string}
\cmdOper{int2str}	{Integer to string conversion}
\cmdOper{mat2str}	{Convert a matrix into a string}
\cmdOper{num2str}	{Number to string conversion}
\cmdOper{sprintf}	{Write formatted data to a string}
\cmdOper{sscanf}	{Read string under format control}
\cmdOper{str2double}	{Convert string to double-precision value}
\cmdOper{str2mat}	{String to matrix conversion}
\cmdOper{str2num}	{String to number conversion}
\subsection{Radix Conversion}{}
\cmdOper{bi\grey{n}2de\grey{c}}	{Binary to decimal number conversion}
\cmdOper{de\grey{c}2bi\grey{n}}	{Nonnegative integer decimal to binary number conversion}
\cmdOper{dec2hex}	{Decimal to hexadecimal number conversion}
\cmdOper{hex2dec}	{Hexadecimal to decimal number conversion}
\cmdOper{hex2num}	{Hexadecimal to double number conversion}

\section{Print \& Write Data to File}{}
\cmdS{csvwrite()}	{write to CSV format in current folder}
\cmdL{print -depsc2 fig.eps}	{saves the current figure into the file $fig.eps$.}

\section{Conditional Statements}{}
\vtop{\tt
    {if expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {elsif expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {else expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}

\vtop{\tt
    {switch switch\_expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {case case\_expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {case case\_expression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
    {otherwise}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}

\vtop{\tt
    {for k = vectorOrColumnList}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}

\vtop{\tt
    {while logicalExpression}\\
    \hbox to 4em {\hskip 2em {statements}}\\
        end
        \vskip 4ex
}
% \section{MATLAB vs R}{}
% http://home.online.no/~pjacklam/r/doc/matlab_vs_r.html

% Matlab vs R function and operator names
% 
% Matlab	 	R
% size          dim
% [...]         c, rbind, cbind
% permute		aperm
% error         stop
% ceil          ceiling
% linspace		seq
% :             : (but behaves differently)
% ones(...)		rep(1, ...), matrix(1, ...), array(1, ...)
% zeros(...)	rep(0, ...), matrix(0, ...), array(0, ...)
% ~             !
% ~=            !=
% logical		as.logical
% cd            getwd, setwd
% cell          list, as.list
% sprintf		formatC
% eval('...')		eval(parse(text = "..."))
% reshape(x, s)		array(x, s), dim(x) <- s

% Footer
\copyrightnotice

% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
